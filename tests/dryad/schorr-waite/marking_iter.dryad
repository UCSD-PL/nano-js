define pred treezero^(x): 
  ( 
	((x l= nil) & emp) | 
          (((x |-> loc left: lft; loc right: rgt; int key: ky) * (treezero^(lft) * treezero^(rgt))) & (ky i= 0))
  )
  
define pred treethree^(x): 
  ( 
	((x l= nil) & emp) | 
          (((x |-> loc left: lft; loc right: rgt; int key: ky) * (treethree^(lft) * treethree^(rgt))) & (ky i= 3))
  )
  

define pred wellmarkedpath^(x): 
  ( 
	((x l= nil) & emp) | 
          ((((x |-> loc left: lft1; loc right: rgt1; int key: ky1) * (treezero^(lft1) * wellmarkedpath^(rgt1))) & (ky1 i= 1)) |
		  (((x |-> loc left: lft2; loc right: rgt2; int key: ky2) * (wellmarkedpath^(lft2) * treethree^(rgt2))) & (ky2 i= 2)))
  )



bb wait-pre:
pre: (treezero^(p) * ((q l= nil) & emp));
post: ((((((p |-> loc left: lft; loc right: rgt; int key: ky) * (treezero^(lft) * treezero^(rgt))) & (ky i= 0)) * wellmarkedpath^(q)) |
       (((((p |-> loc left: lft; loc right: rgt; int key: ky) * (treezero^(lft) * wellmarkedpath^(rgt))) & (ky i= 1)) * treethree^(q)) |
     ((((p |-> loc left: lft; loc right: rgt; int key: ky) * (wellmarkedpath^(lft) * treethree^(rgt))) & (ky i= 2)) * treethree^(q)))) |
	 (((p l= nil) & emp) * treethree^(q)));
{
	loc lft := p.left;
	loc rgt := p.right;
	int ky := p.key;
}

bb inductive1:
pre: ((((((p |-> loc left: lft; loc right: rgt; int key: ky) * (treezero^(lft) * treezero^(rgt))) & (ky i= 0)) * wellmarkedpath^(q)) |
       (((((p |-> loc left: lft; loc right: rgt; int key: ky) * (treezero^(lft) * wellmarkedpath^(rgt))) & (ky i= 1)) * treethree^(q)) |
     ((((p |-> loc left: lft; loc right: rgt; int key: ky) * (wellmarkedpath^(lft) * treethree^(rgt))) & (ky i= 2)) * treethree^(q)))) |
	 (((p l= nil) & emp) * treethree^(q)));
post: ((((((p1 |-> loc left: lft1; loc right: rgt1; int key: ky1) * (treezero^(lft1) * treezero^(rgt1))) & (ky1 i= 0)) * wellmarkedpath^(q1)) |
       (((((p1 |-> loc left: lft1; loc right: rgt1; int key: ky1) * (treezero^(lft1) * wellmarkedpath^(rgt1))) & (ky1 i= 1)) * treethree^(q1)) |
     ((((p1 |-> loc left: lft1; loc right: rgt1; int key: ky1) * (wellmarkedpath^(lft1) * treethree^(rgt1))) & (ky1 i= 2)) * treethree^(q1)))) |
	 (((p1 l= nil) & emp) * treethree^(q1)));
{
	assume (! (p l== nil));
	int pk := p.key;
	int pkadd := pk + 1;
	int p.key := pkadd;
	int pk1 := p.key;
	assume (! (pk1 i== 3));
	loc pleft := p.left;
	assume (! (pleft l== nil));
	loc t := p.left;
	loc pright := p.right;
	loc p.left := pright;
	loc p.right := q;
	
	loc q1 := p;
	loc p1 := t;	

	loc lft1 := p1.left;
	loc rgt1 := p1.right;
	int ky1 := p1.key;
}


bb inductive2:
pre: ((((((p |-> loc left: lft; loc right: rgt; int key: ky) * (treezero^(lft) * treezero^(rgt))) & (ky i= 0)) * wellmarkedpath^(q)) |
       (((((p |-> loc left: lft; loc right: rgt; int key: ky) * (treezero^(lft) * wellmarkedpath^(rgt))) & (ky i= 1)) * treethree^(q)) |
     ((((p |-> loc left: lft; loc right: rgt; int key: ky) * (wellmarkedpath^(lft) * treethree^(rgt))) & (ky i= 2)) * treethree^(q)))) |
	 (((p l= nil) & emp) * treethree^(q)));
post: ((((((p1 |-> loc left: lft1; loc right: rgt1; int key: ky1) * (treezero^(lft1) * treezero^(rgt1))) & (ky1 i= 0)) * wellmarkedpath^(q1)) |
       (((((p1 |-> loc left: lft1; loc right: rgt1; int key: ky1) * (treezero^(lft1) * wellmarkedpath^(rgt1))) & (ky1 i= 1)) * treethree^(q1)) |
     ((((p1 |-> loc left: lft1; loc right: rgt1; int key: ky1) * (wellmarkedpath^(lft1) * treethree^(rgt1))) & (ky1 i= 2)) * treethree^(q1)))) |
	 (((p1 l= nil) & emp) * treethree^(q1)));
{
	assume (! (p l== nil));
	int pk := p.key;
	int pkadd := pk + 1;
	int p.key := pkadd;
	int pk1 := p.key;
	assume (pk1 i== 3);
	loc t := p.left;
	loc pright := p.right;
	loc p.left := pright;
	loc p.right := q;
	
	loc q1 := p;
	loc p1 := t;	

	loc lft1 := p1.left;
	loc rgt1 := p1.right;
	int ky1 := p1.key;
}

bb inductive3:
pre: ((((((p |-> loc left: lft; loc right: rgt; int key: ky) * (treezero^(lft) * treezero^(rgt))) & (ky i= 0)) * wellmarkedpath^(q)) |
       (((((p |-> loc left: lft; loc right: rgt; int key: ky) * (treezero^(lft) * wellmarkedpath^(rgt))) & (ky i= 1)) * treethree^(q)) |
     ((((p |-> loc left: lft; loc right: rgt; int key: ky) * (wellmarkedpath^(lft) * treethree^(rgt))) & (ky i= 2)) * treethree^(q)))) |
	 (((p l= nil) & emp) * treethree^(q)));
post: ((((((p1 |-> loc left: lft1; loc right: rgt1; int key: ky1) * (treezero^(lft1) * treezero^(rgt1))) & (ky1 i= 0)) * wellmarkedpath^(q1)) |
       (((((p1 |-> loc left: lft1; loc right: rgt1; int key: ky1) * (treezero^(lft1) * wellmarkedpath^(rgt1))) & (ky1 i= 1)) * treethree^(q1)) |
     ((((p1 |-> loc left: lft1; loc right: rgt1; int key: ky1) * (wellmarkedpath^(lft1) * treethree^(rgt1))) & (ky1 i= 2)) * treethree^(q1)))) |
	 (((p1 l= nil) & emp) * treethree^(q1)));
{
	assume (! (p l== nil));
	int pk := p.key;
	int pkadd := pk + 1;
	int p.key := pkadd;
	int pk1 := p.key;
	assume (! (pk1 i== 3));
	loc pleft := p.left;
	assume (pleft l== nil);
	loc t := p.left;
	loc pright := p.right;
	loc p.left := pright;
	loc p.right := q;
	
	loc q1 := t;	
	loc p1 := p;

	loc lft1 := p1.left;
	loc rgt1 := p1.right;
	int ky1 := p1.key;
}


bb wait-post:
pre: ((((((p |-> loc left: lft; loc right: rgt; int key: ky) * (treezero^(lft) * treezero^(rgt))) & (ky i= 0)) * wellmarkedpath^(q)) |
       (((((p |-> loc left: lft; loc right: rgt; int key: ky) * (treezero^(lft) * wellmarkedpath^(rgt))) & (ky i= 1)) * treethree^(q)) |
     ((((p |-> loc left: lft; loc right: rgt; int key: ky) * (wellmarkedpath^(lft) * treethree^(rgt))) & (ky i= 2)) * treethree^(q)))) |
	 (((p l= nil) & emp) * treethree^(q)));
post: treethree^(q);
{
	assume (p l== nil);

}