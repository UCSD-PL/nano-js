define pred binomial-heap^(x): 
  ( ((x l= nil) & emp) |
    (
        (x |-> loc children: chld; loc sibling: sbl; int key: ky; int order: odr) * 
        ((
	       (binomial-heap^(sbl) & ((orders^(sbl) set-lt odr) * true)) *
	       ((binomial-heap^(chld) & (ky le-set keys^(chld))) &
	       (((full-list^(chld) & ((length^(chld) + 1) i= odr)) & (orders^(chld) set-lt odr)) * true)
		)
	) & (0 < odr))
    )
  ) ;

define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc children: chld2; loc sibling: sbl2; int key: ky2) * true): 
   	((singleton ky2) union (keys^(chld2) union keys^(sbl2)));
   default: emptyset
  ) ;

define set-fun orders^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc sibling: sbl3; int order: odr3) * true): 
   	((singleton odr3) union orders^(sbl3));
   default: emptyset
  ) ;

define pred full-list^(x): 
  ( ((x l= nil) & emp) |
    (
        (x |-> loc sibling: sbl4; int order: odr4) * 
        (
	       full-list^(sbl4) & ((length^(sbl4) + 1) i= odr4)
	)
    )
  ) ;

define int-fun length^(x):
  (case (x l= nil): 0;
   case ((x |-> loc sibling: sbl5) * true): 
   	(length^(sbl5) + 1);
   default: 0
  ) ;


method merge(loc x, loc y)
requires: (((binomial-heap^(x) & (keys^(x) s= xks)) * (binomial-heap^(y) & (keys^(y) s= yks))) &
	(
	 	(((x l= nil) & (xord i= 0)) | 
		((((x |-> loc sibling: xsib; int order: xord) * (orders^(xsib) set-le xord)) & (orders^(x) s= (orders^(xsib) union (singleton xord)))) * (0 < xord))) &
		(((y l= nil) & (yord i= 0)) | 
		((((y |-> loc sibling: ysib; int order: yord) * (orders^(ysib) set-le yord)) & (orders^(y) s= (orders^(ysib) union (singleton yord)))) * (0 < yord)))
	)) ;
ensures: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xks union yks))) &
		((((xord i= 0) & (yord i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xord i= 0)) | (~ (yord i= 0))) & 
		    (((xord i= yord) & (retord i= (xord + 1))) |
		    ((((xord < yord) & (retord i= (yord + 1))) |
		    ((xord < yord) & (retord i= yord))) |
		    (((yord < xord) & (retord i= (xord + 1))) |
		    ((yord < xord) & (retord i= xord)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsib; int order: retord) * (orders^(retsib) set-le retord)) & (orders^(ret) s= (orders^(retsib) union (singleton retord)))) * true))
		 )
	);


bb merge-both-nil:
pre: (((binomial-heap^(x) & (keys^(x) s= xks)) * (binomial-heap^(y) & (keys^(y) s= yks))) &
	(
	 	(((x l= nil) & (xord i= 0)) | 
		((((x |-> loc sibling: xsib; int order: xord) * (orders^(xsib) set-le xord)) & (orders^(x) s= (orders^(xsib) union (singleton xord)))) * (0 < xord))) &
		(((y l= nil) & (yord i= 0)) | 
		((((y |-> loc sibling: ysib; int order: yord) * (orders^(ysib) set-le yord)) & (orders^(y) s= (orders^(ysib) union (singleton yord)))) * (0 < yord)))
	)) ;
post: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xks union yks))) &
		((((xord i= 0) & (yord i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xord i= 0)) | (~ (yord i= 0))) & 
		    (((xord i= yord) & (retord i= (xord + 1))) |
		    ((((xord < yord) & (retord i= (yord + 1))) |
		    ((xord < yord) & (retord i= yord))) |
		    (((yord < xord) & (retord i= (xord + 1))) |
		    ((yord < xord) & (retord i= xord)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsib; int order: retord) * (orders^(retsib) set-le retord)) & (orders^(ret) s= (orders^(retsib) union (singleton retord)))) * true))
		 )
	);
{
	assume (x l== nil);
	assume (y l== nil);
	loc ret := y;
}

bb merge-x-nil:
pre: (((binomial-heap^(x) & (keys^(x) s= xks)) * (binomial-heap^(y) & (keys^(y) s= yks))) &
	(
	 	(((x l= nil) & (xord i= 0)) | 
		((((x |-> loc sibling: xsib; int order: xord) * (orders^(xsib) set-le xord)) & (orders^(x) s= (orders^(xsib) union (singleton xord)))) * (0 < xord))) &
		(((y l= nil) & (yord i= 0)) | 
		((((y |-> loc sibling: ysib; int order: yord) * (orders^(ysib) set-le yord)) & (orders^(y) s= (orders^(ysib) union (singleton yord)))) * (0 < yord)))
	)) ;
post: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xks union yks))) &
		((((xord i= 0) & (yord i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xord i= 0)) | (~ (yord i= 0))) & 
		    (((xord i= yord) & (retord i= (xord + 1))) |
		    ((((xord < yord) & (retord i= (yord + 1))) |
		    ((xord < yord) & (retord i= yord))) |
		    (((yord < xord) & (retord i= (xord + 1))) |
		    ((yord < xord) & (retord i= xord)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsib; int order: retord) * (orders^(retsib) set-le retord)) & (orders^(ret) s= (orders^(retsib) union (singleton retord)))) * true))
		 )
	);
{
	assume (x l== nil);
	assume (! (y l== nil));
	int yo := y.order;
	loc ret := y;
	loc retsib := ret.sibling;
	int retord := ret.order;
}

bb merge-y-nil:
pre: (((binomial-heap^(x) & (keys^(x) s= xks)) * (binomial-heap^(y) & (keys^(y) s= yks))) &
	(
	 	(((x l= nil) & (xord i= 0)) | 
		((((x |-> loc sibling: xsib; int order: xord) * (orders^(xsib) set-le xord)) & (orders^(x) s= (orders^(xsib) union (singleton xord)))) * (0 < xord))) &
		(((y l= nil) & (yord i= 0)) | 
		((((y |-> loc sibling: ysib; int order: yord) * (orders^(ysib) set-le yord)) & (orders^(y) s= (orders^(ysib) union (singleton yord)))) * (0 < yord)))
	)) ;
post: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xks union yks))) &
		((((xord i= 0) & (yord i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xord i= 0)) | (~ (yord i= 0))) & 
		    (((xord i= yord) & (retord i= (xord + 1))) |
		    ((((xord < yord) & (retord i= (yord + 1))) |
		    ((xord < yord) & (retord i= yord))) |
		    (((yord < xord) & (retord i= (xord + 1))) |
		    ((yord < xord) & (retord i= xord)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsib; int order: retord) * (orders^(retsib) set-le retord)) & (orders^(ret) s= (orders^(retsib) union (singleton retord)))) * true))
		 )
	);
{
	assume (! (x l== nil));
	assume (y l== nil);
	int xo := x.order;
	loc ret := x;
	loc retsib := ret.sibling;
	int retord := ret.order;
}

bb merge-equal-pre:
pre: (((binomial-heap^(x) & (keys^(x) s= xks)) * (binomial-heap^(y) & (keys^(y) s= yks))) &
	(
	 	(((x l= nil) & (xord i= 0)) | 
		((((x |-> loc sibling: xsib; int order: xord) * (orders^(xsib) set-le xord)) & (orders^(x) s= (orders^(xsib) union (singleton xord)))) * (0 < xord))) &
		(((y l= nil) & (yord i= 0)) | 
		((((y |-> loc sibling: ysib; int order: yord) * (orders^(ysib) set-le yord)) & (orders^(y) s= (orders^(ysib) union (singleton yord)))) * (0 < yord)))
	)) ;
post: ((binomial-heap^(xs) * binomial-heap^(ys)) *
	true) ;
{
	assume (! (x l== nil));
	assume (! (y l== nil));
	int ord1 := x.order;
	int ord2 := y.order;
	assume (ord1 i== ord2);
	loc xs := x.sibling;
	loc ys := y.sibling;
}

bb merge-equal-if:
pre: (((binomial-heap^(x) & (keys^(x) s= xkss)) * (binomial-heap^(y) & (keys^(y) s= ykss))) &
	(
	 	(((x l= nil) & (xordd i= 0)) | 
		((((x |-> loc sibling: xsibb; int order: xordd) * (orders^(xsibb) set-le xordd)) & (orders^(x) s= (orders^(xsibb) union (singleton xordd)))) * (0 < xordd))) &
		(((y l= nil) & (yordd i= 0)) | 
		((((y |-> loc sibling: ysibb; int order: yordd) * (orders^(ysibb) set-le yordd)) & (orders^(y) s= (orders^(ysibb) union (singleton yordd)))) * (0 < yordd)))
	)) ;
post: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xkss union ykss))) &
		((((xordd i= 0) & (yordd i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xordd i= 0)) | (~ (yordd i= 0))) & 
		    (((xordd i= yordd) & (retordd i= (xordd + 1))) |
		    ((((xordd < yordd) & (retordd i= (yordd + 1))) |
		    ((xordd < yordd) & (retordd i= yordd))) |
		    (((yordd < xordd) & (retordd i= (xordd + 1))) |
		    ((yordd < xordd) & (retordd i= xordd)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsibb; int order: retordd) * (orders^(retsibb) set-le retordd)) & (orders^(ret) s= (orders^(retsibb) union (singleton retordd)))) * true))
		 )
	);
{
	assume (! (x l== nil));
	assume (! (y l== nil));
	int ord1 := x.order;
	int ord2 := y.order;
	assume (ord1 i== ord2);
	loc xs := x.sibling;
	loc ys := y.sibling;
	loc z := merge(xs, ys);
	int xk := x.key;
	int yk := y.key;
	assume (xk <= yk);
	loc xchld := x.children;
	loc y.sibling := xchld;
	loc x.children := y;
	loc x.sibling := z;
	int retordd := ord1 + 1;
	int x.order := retordd;
	loc ret := x;
	loc retsibb := ret.sibling;
	int retordd := ret.order;
}

bb merge-equal-else:
pre: (((binomial-heap^(x) & (keys^(x) s= xkss)) * (binomial-heap^(y) & (keys^(y) s= ykss))) &
	(
	 	(((x l= nil) & (xordd i= 0)) | 
		((((x |-> loc sibling: xsibb; int order: xordd) * (orders^(xsibb) set-le xordd)) & (orders^(x) s= (orders^(xsibb) union (singleton xordd)))) * (0 < xordd))) &
		(((y l= nil) & (yordd i= 0)) | 
		((((y |-> loc sibling: ysibb; int order: yordd) * (orders^(ysibb) set-le yordd)) & (orders^(y) s= (orders^(ysibb) union (singleton yordd)))) * (0 < yordd)))
	)) ;
post: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xkss union ykss))) &
		((((xordd i= 0) & (yordd i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xordd i= 0)) | (~ (yordd i= 0))) & 
		    (((xordd i= yordd) & (retordd i= (xordd + 1))) |
		    ((((xordd < yordd) & (retordd i= (yordd + 1))) |
		    ((xordd < yordd) & (retordd i= yordd))) |
		    (((yordd < xordd) & (retordd i= (xordd + 1))) |
		    ((yordd < xordd) & (retordd i= xordd)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsibb; int order: retordd) * (orders^(retsibb) set-le retordd)) & (orders^(ret) s= (orders^(retsibb) union (singleton retordd)))) * true))
		 )
	);
{
	assume (! (x l== nil));
	assume (! (y l== nil));
	int ord1 := x.order;
	int ord2 := y.order;
	assume (ord1 i== ord2);
	loc xs := x.sibling;
	loc ys := y.sibling;
	loc z := merge(xs, ys);
	int xk := x.key;
	int yk := y.key;
	assume (! (xk <= yk));
	loc ychld := y.children;
	loc x.sibling := ychld;
	loc y.children := x;
	loc y.sibling := z;
	int retordd := ord2 + 1;
	int y.order := retordd;
	loc ret := y;
	loc retsibb := ret.sibling;
	int retordd := ret.order;
}


bb merge-greater-pre:
pre: (((binomial-heap^(x) & (keys^(x) s= xks)) * (binomial-heap^(y) & (keys^(y) s= yks))) &
	(
	 	(((x l= nil) & (xord i= 0)) | 
		((((x |-> loc sibling: xsib; int order: xord) * (orders^(xsib) set-le xord)) & (orders^(x) s= (orders^(xsib) union (singleton xord)))) * (0 < xord))) &
		(((y l= nil) & (yord i= 0)) | 
		((((y |-> loc sibling: ysib; int order: yord) * (orders^(ysib) set-le yord)) & (orders^(y) s= (orders^(ysib) union (singleton yord)))) * (0 < yord)))
	)) ;
post: ((binomial-heap^(xs) * binomial-heap^(y)) *
	true) ;
{
	assume (! (x l== nil));
	assume (! (y l== nil));
	int ord1 := x.order;
	int ord2 := y.order;
	assume (ord2 < ord1);
	loc xs := x.sibling;
}

bb merge-greater-case1:
pre: (((binomial-heap^(x) & (keys^(x) s= xkss)) * (binomial-heap^(y) & (keys^(y) s= ykss))) &
	(
	 	(((x l= nil) & (xordd i= 0)) | 
		((((x |-> loc sibling: xsibb; int order: xordd) * (orders^(xsibb) set-le xordd)) & (orders^(x) s= (orders^(xsibb) union (singleton xordd)))) * (0 < xordd))) &
		(((y l= nil) & (yordd i= 0)) | 
		((((y |-> loc sibling: ysibb; int order: yordd) * (orders^(ysibb) set-le yordd)) & (orders^(y) s= (orders^(ysibb) union (singleton yordd)))) * (0 < yordd)))
	)) ;
post: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xkss union ykss))) &
		((((xordd i= 0) & (yordd i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xordd i= 0)) | (~ (yordd i= 0))) & 
		    (((xordd i= yordd) & (retordd i= (xordd + 1))) |
		    ((((xordd < yordd) & (retordd i= (yordd + 1))) |
		    ((xordd < yordd) & (retordd i= yordd))) |
		    (((yordd < xordd) & (retordd i= (xordd + 1))) |
		    ((yordd < xordd) & (retordd i= xordd)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsibb; int order: retordd) * (orders^(retsibb) set-le retordd)) & (orders^(ret) s= (orders^(retsibb) union (singleton retordd)))) * true))
		 )
	);
{
	assume (! (x l== nil));
	assume (! (y l== nil));
	int ord1 := x.order;
	int ord2 := y.order;
	assume (ord2 < ord1);
	loc xs := x.sibling;
	loc z := merge(xs, y);
	int zord := z.order;
	int zk := z.key;
	int xk := x.key;
	assume ((ord1 i== zord) && (zk <= xk));
	loc zchld := z.children;
	loc x.sibling := zchld;
	loc z.children := x;
	int retordd := zord + 1;
	int z.order := retordd;
	loc ret := z;
	loc retsibb := ret.sibling;
	int retordd := ret.order;
}

bb merge-greater-case2:
pre: (((binomial-heap^(x) & (keys^(x) s= xkss)) * (binomial-heap^(y) & (keys^(y) s= ykss))) &
	(
	 	(((x l= nil) & (xordd i= 0)) | 
		((((x |-> loc sibling: xsibb; int order: xordd) * (orders^(xsibb) set-le xordd)) & (orders^(x) s= (orders^(xsibb) union (singleton xordd)))) * (0 < xordd))) &
		(((y l= nil) & (yordd i= 0)) | 
		((((y |-> loc sibling: ysibb; int order: yordd) * (orders^(ysibb) set-le yordd)) & (orders^(y) s= (orders^(ysibb) union (singleton yordd)))) * (0 < yordd)))
	)) ;
post: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xkss union ykss))) &
		((((xordd i= 0) & (yordd i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xordd i= 0)) | (~ (yordd i= 0))) & 
		    (((xordd i= yordd) & (retordd i= (xordd + 1))) |
		    ((((xordd < yordd) & (retordd i= (yordd + 1))) |
		    ((xordd < yordd) & (retordd i= yordd))) |
		    (((yordd < xordd) & (retordd i= (xordd + 1))) |
		    ((yordd < xordd) & (retordd i= xordd)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsibb; int order: retordd) * (orders^(retsibb) set-le retordd)) & (orders^(ret) s= (orders^(retsibb) union (singleton retordd)))) * true))
		 )
	);
{
	assume (! (x l== nil));
	assume (! (y l== nil));
	int ord1 := x.order;
	int ord2 := y.order;
	assume (ord2 < ord1);
	loc xs := x.sibling;
	loc z := merge(xs, y);
	int zord := z.order;
	int zk := z.key;
	int xk := x.key;
	assume (! ((ord1 i== zord) && (zk <= xk)));
	assume ((ord1 i== zord) && (xk < zk));
	loc zsib := z.sibling;
	loc x.sibling := zsib;
	loc xchld := x.children;
	loc z.sibling := xchld;
	loc x.children := z;
	int retordd := ord1 + 1;
	int x.order := retordd;
	loc ret := x;
	loc retsibb := ret.sibling;
	int retordd := ret.order;
}

bb merge-greater-case3:
pre: (((binomial-heap^(x) & (keys^(x) s= xkss)) * (binomial-heap^(y) & (keys^(y) s= ykss))) &
	(
	 	(((x l= nil) & (xordd i= 0)) | 
		((((x |-> loc sibling: xsibb; int order: xordd) * (orders^(xsibb) set-le xordd)) & (orders^(x) s= (orders^(xsibb) union (singleton xordd)))) * (0 < xordd))) &
		(((y l= nil) & (yordd i= 0)) | 
		((((y |-> loc sibling: ysibb; int order: yordd) * (orders^(ysibb) set-le yordd)) & (orders^(y) s= (orders^(ysibb) union (singleton yordd)))) * (0 < yordd)))
	)) ;
post: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xkss union ykss))) &
		((((xordd i= 0) & (yordd i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xordd i= 0)) | (~ (yordd i= 0))) & 
		    (((xordd i= yordd) & (retordd i= (xordd + 1))) |
		    ((((xordd < yordd) & (retordd i= (yordd + 1))) |
		    ((xordd < yordd) & (retordd i= yordd))) |
		    (((yordd < xordd) & (retordd i= (xordd + 1))) |
		    ((yordd < xordd) & (retordd i= xordd)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsibb; int order: retordd) * (orders^(retsibb) set-le retordd)) & (orders^(ret) s= (orders^(retsibb) union (singleton retordd)))) * true))
		 )
	);
{
	assume (! (x l== nil));
	assume (! (y l== nil));
	int ord1 := x.order;
	int ord2 := y.order;
	assume (ord2 < ord1);
	loc xs := x.sibling;
	loc z := merge(xs, y);
	int zord := z.order;
	int zk := z.key;
	int xk := x.key;
	assume (! ((ord1 i== zord) && (zk <= xk)));
	assume (! ((ord1 i== zord) && (xk < zk)));
	loc x.sibling := z;
	loc ret := x;
	loc retsibb := ret.sibling;
	int retordd := ret.order;
}

bb merge-less-pre:
pre: (((binomial-heap^(x) & (keys^(x) s= xks)) * (binomial-heap^(y) & (keys^(y) s= yks))) &
	(
	 	(((x l= nil) & (xord i= 0)) | 
		((((x |-> loc sibling: xsib; int order: xord) * (orders^(xsib) set-le xord)) & (orders^(x) s= (orders^(xsib) union (singleton xord)))) * (0 < xord))) &
		(((y l= nil) & (yord i= 0)) | 
		((((y |-> loc sibling: ysib; int order: yord) * (orders^(ysib) set-le yord)) & (orders^(y) s= (orders^(ysib) union (singleton yord)))) * (0 < yord)))
	)) ;
post: ((binomial-heap^(ys) * binomial-heap^(x)) *
	true) ;
{
	assume (! (x l== nil));
	assume (! (y l== nil));
	int ord1 := x.order;
	int ord2 := y.order;
	assume (! (ord2 < ord1));
	loc ys := y.sibling;
}

bb merge-less-case1:
pre: (((binomial-heap^(x) & (keys^(x) s= xkss)) * (binomial-heap^(y) & (keys^(y) s= ykss))) &
	(
	 	(((x l= nil) & (xordd i= 0)) | 
		((((x |-> loc sibling: xsibb; int order: xordd) * (orders^(xsibb) set-le xordd)) & (orders^(x) s= (orders^(xsibb) union (singleton xordd)))) * (0 < xordd))) &
		(((y l= nil) & (yordd i= 0)) | 
		((((y |-> loc sibling: ysibb; int order: yordd) * (orders^(ysibb) set-le yordd)) & (orders^(y) s= (orders^(ysibb) union (singleton yordd)))) * (0 < yordd)))
	)) ;
post: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xkss union ykss))) &
		((((xordd i= 0) & (yordd i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xordd i= 0)) | (~ (yordd i= 0))) & 
		    (((xordd i= yordd) & (retordd i= (xordd + 1))) |
		    ((((xordd < yordd) & (retordd i= (yordd + 1))) |
		    ((xordd < yordd) & (retordd i= yordd))) |
		    (((yordd < xordd) & (retordd i= (xordd + 1))) |
		    ((yordd < xordd) & (retordd i= xordd)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsibb; int order: retordd) * (orders^(retsibb) set-le retordd)) & (orders^(ret) s= (orders^(retsibb) union (singleton retordd)))) * true))
		 )
	);
{
	assume (! (x l== nil));
	assume (! (y l== nil));
	int ord1 := x.order;
	int ord2 := y.order;
	assume (! (ord2 < ord1));
	loc ys := y.sibling;
	loc z := merge(ys, x);
	int zord := z.order;
	int zk := z.key;
	int yk := y.key;
	assume ((ord2 i== zord) && (zk <= yk));
	loc zchld := z.children;
	loc y.sibling := zchld;
	loc z.children := y;
	int retordd := zord + 1;
	int z.order := retordd;
	loc ret := z;
	loc retsibb := ret.sibling;
	int retordd := ret.order;
}

bb merge-less-case2:
pre: (((binomial-heap^(x) & (keys^(x) s= xkss)) * (binomial-heap^(y) & (keys^(y) s= ykss))) &
	(
	 	(((x l= nil) & (xordd i= 0)) | 
		((((x |-> loc sibling: xsibb; int order: xordd) * (orders^(xsibb) set-le xordd)) & (orders^(x) s= (orders^(xsibb) union (singleton xordd)))) * (0 < xordd))) &
		(((y l= nil) & (yordd i= 0)) | 
		((((y |-> loc sibling: ysibb; int order: yordd) * (orders^(ysibb) set-le yordd)) & (orders^(y) s= (orders^(ysibb) union (singleton yordd)))) * (0 < yordd)))
	)) ;
post: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xkss union ykss))) &
		((((xordd i= 0) & (yordd i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xordd i= 0)) | (~ (yordd i= 0))) & 
		    (((xordd i= yordd) & (retordd i= (xordd + 1))) |
		    ((((xordd < yordd) & (retordd i= (yordd + 1))) |
		    ((xordd < yordd) & (retordd i= yordd))) |
		    (((yordd < xordd) & (retordd i= (xordd + 1))) |
		    ((yordd < xordd) & (retordd i= xordd)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsibb; int order: retordd) * (orders^(retsibb) set-le retordd)) & (orders^(ret) s= (orders^(retsibb) union (singleton retordd)))) * true))
		 )
	);
{
	assume (! (x l== nil));
	assume (! (y l== nil));
	int ord1 := x.order;
	int ord2 := y.order;
	assume (! (ord2 < ord1));
	loc ys := y.sibling;
	loc z := merge(x, ys);
	int zord := z.order;
	int zk := z.key;
	int yk := y.key;
	assume (! ((ord2 i== zord) && (zk <= yk)));
	assume ((ord2 i== zord) && (yk < zk));
	loc zsib := z.sibling;
	loc y.sibling := zsib;
	loc ychld := y.children;
	loc z.sibling := ychld;
	loc y.children := z;
	int retordd := ord2 + 1;
	int y.order := retordd;
	loc ret := y;
	loc retsibb := ret.sibling;
	int retordd := ret.order;
}

bb merge-less-case3:
pre: (((binomial-heap^(x) & (keys^(x) s= xkss)) * (binomial-heap^(y) & (keys^(y) s= ykss))) &
	(
	 	(((x l= nil) & (xordd i= 0)) | 
		((((x |-> loc sibling: xsibb; int order: xordd) * (orders^(xsibb) set-le xordd)) & (orders^(x) s= (orders^(xsibb) union (singleton xordd)))) * (0 < xordd))) &
		(((y l= nil) & (yordd i= 0)) | 
		((((y |-> loc sibling: ysibb; int order: yordd) * (orders^(ysibb) set-le yordd)) & (orders^(y) s= (orders^(ysibb) union (singleton yordd)))) * (0 < yordd)))
	)) ;
post: ( 
	(binomial-heap^(ret) & (keys^(ret) s= (xkss union ykss))) &
		((((xordd i= 0) & (yordd i= 0)) & ((ret l= nil) & emp)) |
		 ((((~ (xordd i= 0)) | (~ (yordd i= 0))) & 
		    (((xordd i= yordd) & (retordd i= (xordd + 1))) |
		    ((((xordd < yordd) & (retordd i= (yordd + 1))) |
		    ((xordd < yordd) & (retordd i= yordd))) |
		    (((yordd < xordd) & (retordd i= (xordd + 1))) |
		    ((yordd < xordd) & (retordd i= xordd)))))
		   )
		    & 
		  ((((ret |-> loc sibling: retsibb; int order: retordd) * (orders^(retsibb) set-le retordd)) & (orders^(ret) s= (orders^(retsibb) union (singleton retordd)))) * true))
		 )
	);
{
	assume (! (x l== nil));
	assume (! (y l== nil));
	int ord1 := x.order;
	int ord2 := y.order;
	assume (! (ord2 < ord1));
	loc ys := y.sibling;
	loc z := merge(ys, x);
	int zord := z.order;
	int zk := z.key;
	int yk := y.key;
	assume (! ((ord2 i== zord) && (zk <= yk)));
	assume (! ((ord2 i== zord) && (yk < zk)));
	loc y.sibling := z;
	loc ret := y;
	loc retsibb := ret.sibling;
	int retordd := ret.order;
}



