define pred binomial-heap^(x): 
  ( ((x l= nil) & emp) |
    (
        (x |-> loc children: chld; loc sibling: sbl; int key: ky; int order: odr) * 
        ((
	       (binomial-heap^(sbl) & ((orders^(sbl) set-lt odr) * true)) *
	       ((binomial-heap^(chld) & (ky le-set keys^(chld))) &
	       (((full-list^(chld) & ((length^(chld) + 1) i= odr)) & (orders^(chld) set-lt odr)) * true)
		)
	) & (0 < odr))
    )
  ) ;

define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc children: chld2; loc sibling: sbl2; int key: ky2) * true): 
   	((singleton ky2) union (keys^(chld2) union keys^(sbl2)));
   default: emptyset
  ) ;

define set-fun orders^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc sibling: sbl3; int order: odr3) * true): 
   	((singleton odr3) union orders^(sbl3));
   default: emptyset
  ) ;

define pred full-list^(x): 
  ( ((x l= nil) & emp) |
    (
        (x |-> loc sibling: sbl4; int order: odr4) * 
        (
	       full-list^(sbl4) & ((length^(sbl4) + 1) i= odr4)
	)
    )
  ) ;

define int-fun length^(x):
  (case (x l= nil): 0;
   case ((x |-> loc sibling: sbl5) * true): 
   	(length^(sbl5) + 1);
   default: 0
  ) ;


method find-minimum(loc x)
requires: ((~ (x l= nil)) & ((binomial-heap^(x) & (keys^(x) s= xks)) & ((orders^(x) s= ods) * true))) ;
ensures: (((ret le-set xks) & (ret i-in xks)) & ((binomial-heap^(x) & (keys^(x) s= xks)) & ((orders^(x) s= ods) * true)));


bb find-minimum-nil:
pre: ((~ (x l= nil)) & ((binomial-heap^(x) & (keys^(x) s= xks)) & ((orders^(x) s= ods) * true))) ;
post: (((ret le-set xks) & (ret i-in xks)) & ((binomial-heap^(x) & (keys^(x) s= xks)) & ((orders^(x) s= ods) * true)));
{
	loc xs := x.sibling;
	assume (xs l== nil);
	int ret := x.key;
}

bb find-minimum-recursive-pre:
pre: ((~ (x l= nil)) & ((binomial-heap^(x) & (keys^(x) s= xks)) & ((orders^(x) s= ods) * true))) ;
post: ((~ (xs l= nil)) & (binomial-heap^(xs) * true)) ;
{
	loc xs := x.sibling;
	assume (! (xs l== nil));
}

bb find-minimum-recursive-if:
pre: ((~ (x l= nil)) & ((binomial-heap^(x) & (keys^(x) s= xkss)) & ((orders^(x) s= odss) * true))) ;
post: (((ret le-set xkss) & (ret i-in xkss)) & ((binomial-heap^(x) & (keys^(x) s= xkss)) & ((orders^(x) s= odss) * true)));
{
	loc xs := x.sibling;
	assume (! (xs l== nil));
	int y := find-minimum(xs);
	int xk := x.key;
	assume (xk <= y);
	int ret := xk;
}

bb find-minimum-recursive-else:
pre: ((~ (x l= nil)) & ((binomial-heap^(x) & (keys^(x) s= xkss)) & ((orders^(x) s= odss) * true))) ;
post: (((ret le-set xkss) & (ret i-in xkss)) & ((binomial-heap^(x) & (keys^(x) s= xkss)) & ((orders^(x) s= odss) * true)));
{
	loc xs := x.sibling;
	assume (! (xs l== nil));
	int y := find-minimum(xs);
	int xk := x.key;
	assume (! (xk <= y));
	int ret := y;
}
