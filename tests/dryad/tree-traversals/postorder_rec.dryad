define pred tree^(x):
	( ((x l= nil) & emp)
	| ((x |-> loc left: lft; loc right: rgt; int key: ky) * (tree^(lft) * tree^(rgt)))  
	);

define pred posttree^(x):
	( ((x l= nil) & emp)
	| (((x |-> loc left: lft; loc right: rgt; int key: ky) * (posttree^(lft) * posttree^(rgt)))
		& ((((((order^(lft) + 1) + size^(rgt)) i= ky) * true) | (lft l= nil))
		& ((((order^(rgt) + 1) i= ky) * true) | (rgt l= nil))))  
	);

define int-fun order^(x):
	( case (x l= nil): 0;
	  case ((x |-> loc left: lft; loc right: rgt; int key: ky) * true): 
		ky;
	  default: 0
	);

define int-fun size^(x):
	( case (x l= nil): 0;
	  case ((x |-> loc left: lft; loc right: rgt; int key: ky) * true): 
		(1 + (size^(lft) + size^(rgt)));
	  default: 0
	);


method postorder(loc x, int n)
requires: (tree^(x) & (szarg i= size^(x)));
ensures: (posttree^(x) & ((ret i= (n + szarg)) & (((order^(x) i= ((n + szarg) - 1)) | (x l= nil)) & (size^(x) i= szarg))));


bb postorder-basic:
pre: (tree^(x) & (sz i= size^(x)));
post: (posttree^(x) & ((ret i= (n + sz)) & (((order^(x) i= ((n + sz) - 1)) | (x l= nil)) & (size^(x) i= sz))));
{
	assume (x l== nil);
	int ret := n;
}

bb postorder-inductive:
pre: (tree^(x) & (sz i= size^(x)));
post: (posttree^(x) & ((ret i= (n + sz)) & (((order^(x) i= ((n + sz) - 1)) | (x l= nil)) & (size^(x) i= sz))));
{
	assume (! (x l== nil));
	loc xl := x.left;
	int n1 := postorder(xl; n);
	loc xr := x.right;
	int n2 := postorder(xr; n1);
	int x.key := n2;
	int n3 := n2 + 1;
	int ret := n3;
}

bb postorder-call1:
pre: (tree^(x) & (sz i= size^(x)));
post: (tree^(xl) * true);
{
	assume (! (x l== nil));
	loc xl := x.left;
}

bb postorder-call2:
pre: (tree^(x) & (sz i= size^(x)));
post: (tree^(xr) * true);
{
	assume (! (x l== nil));
	loc xl := x.left;
	int n1 := postorder(xl; n);
	loc xr := x.right;
}
