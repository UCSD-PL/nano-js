define pred bst^(x): 
  ( ((x l= nil) & emp) |
	  ((x |-> loc left: lft; loc right: rgt; int key: ky) * ((bst^(lft) & (keys^(lft) set-lt ky)) * (bst^(rgt) & (ky lt-set keys^(rgt)))))  
  );


define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int key: ky) * true): 
   	((singleton ky) union (keys^(lft) union keys^(rgt)));
   default: emptyset
  ) ;


define relation bst-with-leftmost-hole^(root, hole):
  ( (((root l= hole) | (root l= nil)) & emp) |
         ( (root |-> loc left: lft; loc right: rgt; int key: ky) *
           ((bst-with-leftmost-hole^(lft, hole) & (keys-leftmost^(lft, hole) set-lt ky)) * (bst^(rgt) & (ky lt-set keys^(rgt)))) )
  )
  axiom: ( (bst^(hole) -* ((keys^(hole) lt keys-leftmost^(root, hole)) => (bst^(root) & (keys^(root) s= (keys-leftmost^(root, hole) union keys^(hole)))))) &

         ( ((hole |-> loc left: virtual hl; loc right: virtual hr; int key: virtual hk) * (bst^(hr) & (hk lt-set keys^(hr)))) -*
          (((keys^(hr) lt keys-leftmost^(root, hole)) * true) =>
           (bst-with-leftmost-hole^(root, hl) & (keys-leftmost^(root, hl) s= (keys-leftmost^(root, hole) union ((singleton hk) union keys^(hr)))))) ) ) ;


define bin-set-fun keys-leftmost^(root, hole):
  (case ((root l= hole) | (root l= nil)): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int key: ky) * true):
        ((singleton ky) union (keys-leftmost^(lft, hole) union keys^(rgt)));
   default: emptyset
  ) ;



method bst-find-leftmost(loc x)
requires: ((bst^(x) & (keys^(x) s= xks2)) & ((~ (x l= nil)) & ((x |-> loc left: xlft) * (~ (xlft l= nil))))) ;
ensures: ((
	( bst-with-leftmost-hole^(x, ret) *  
	  ( (ret |-> loc left: clft; loc right: crgt; int key: cky) * 
	    ( ( ((clft |-> loc left: clftlft; loc right: clftrgt; int key: clftky) * ((clftlft l= nil) & (bst^(clftrgt) & (clftky lt-set keys^(clftrgt))))) & (keys^(clft) set-lt cky) )
	      * (bst^(crgt) & (cky lt-set keys^(crgt))) ) 
	   ) )
      & (keys^(ret) lt keys-leftmost^(x, ret)) 
      ) & (xks2 s= (keys^(ret) union keys-leftmost^(x, ret)))) ;



bb bst-removeroot-iter-left-nil:
pre: ((bst^(x) & (keys^(x) s= xks)) & ((x |-> int key: ky) * true)) ;
post: (bst^(ret) & (keys^(ret) s= (xks setminus (singleton ky)))) ;
{
	loc xl := x.left;
	loc xr := x.right;
	assume (xl l== nil);
	free x;
	loc ret := xr;
}

bb bst-removeroot-iter-right-nil:
pre: ((bst^(x) & (keys^(x) s= xks)) & ((x |-> int key: ky) * true)) ;
post: (bst^(ret) & (keys^(ret) s= (xks setminus (singleton ky)))) ;
{
	loc xl := x.left;
	loc xr := x.right;
	assume (! (xl l== nil));
	assume (xr l== nil);
	free x;
	loc ret := xl;
}

bb bst-removeroot-iter-rightleft-nil:
pre: ((bst^(x) & (keys^(x) s= xks)) & ((x |-> int key: ky) * true)) ;
post: (bst^(ret) & (keys^(ret) s= (xks setminus (singleton ky)))) ;
{
	loc xl := x.left;
	loc xr := x.right;
	assume (! (xl l== nil));
	assume (! (xr l== nil));
	loc xrl := xr.left;
	loc xrr := xr.right;
	int xrk := xr.key;
	assume (xrl l== nil);
	free xr;
	loc x.right := xrr;
	int x.key := xrk;
	loc ret := x;
}

bb bst-removeroot-iter-call:
pre: ((bst^(x) & (keys^(x) s= xks)) & ((x |-> int key: ky) * true)) ;
post: (bst^(ret) & (keys^(ret) s= (xks setminus (singleton ky)))) ;
{
	loc xl := x.left;
	loc xr := x.right;
	assume (! (xl l== nil));
	assume (! (xr l== nil));
	loc xrl := xr.left;
	loc xrr := xr.right;
	int xrk := xr.key;
	assume (! (xrl l== nil));
	loc temp := bst-find-leftmost(xr);
	loc tmpl := temp.left;
	loc tmplr := tmpl.right;
	int tmplk := tmpl.key;
	int x.key := tmplk;
	loc temp.left := tmplr;
	free tmpl;
	loc ret := x;
}
