define pred sll^(x): 
  ( 
	((x l= nil) & emp) | 
          ((x |-> loc next: nxt; int location: ky) * sll^(nxt))  
  )
  axiom: (lseg^(x, x) * (((x l= nil) & (locs^(x) s= emptyset)) | ((~ (x l= nil)) & (~ (locs^(x) s= emptyset)))));

define pred sorted-sll^(x): 
  ( 
	((x l= nil) & emp) | 
          ((x |-> loc next: nxt; int location: ky) * 
			(sorted-sll^(nxt) & (ky lt-set locs^(nxt)))
		  )  
  )
  axiom: (sorted-lseg^(x, x) * sll^(x));
  
define set-fun locs^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc next: nxt; int location: ky) * true): 
   	((singleton ky) union locs^(nxt));
   default: emptyset
  ) ;

define relation lseg^(head, tail): 
  ( 
	((head l= tail) & emp) | 
          ((head |-> loc next: nxt; int location: ky) * (lseg^(nxt, tail) & (ky lt-set lseg-locs^(nxt, tail))))  
  ) 
  axiom: ( (((head l= tail) => (emp & (lseg-locs^(head, tail) s= emptyset))) & ((tail l= nil) => (sll^(head) & (locs^(head) s= lseg-locs^(head, tail))))) &
	( (sll^(tail) -* (sll^(head) & (locs^(head) s= (lseg-locs^(head, tail) union locs^(tail))))) &
	  (((tail |-> loc next: virtual tn; int location: virtual tk) * sll^(tn)) -* ((lseg^(head, tn) & (lseg-locs^(head, tn) s= (lseg-locs^(head, tail) union (singleton tk)))) * sll^(tn))) ) ) ;

define relation sorted-lseg^(head, tail): 
  ( 
	((head l= tail) & emp) | 
          ((head |-> loc next: nxt; int location: ky) * (sorted-lseg^(nxt, tail) & (ky lt-set lseg-locs^(nxt, tail))))  
  ) 
  axiom: ( lseg^(head, tail) &
	  ( ((tail l= nil) => sorted-sll^(head)) &
	( (sorted-sll^(tail) -* ((lseg-locs^(head, tail) lt locs^(tail)) => sorted-sll^(head))) &
	  (((tail |-> loc next: virtual tn; int location: virtual tk) * sll^(tn)) -* (((lseg-locs^(head, tail) set-lt tk) * true) => (sorted-lseg^(head, tn) * sll^(tn)))) ) ) ) ;

define bin-set-fun lseg-locs^(head, tail):
  (case (head l= tail) : emptyset;
   case ((head |-> loc next: nxt; int location: ky) * true): 
   	((singleton ky) union lseg-locs^(nxt, tail));
   default: emptyset
  ) ;



method lookupprev(loc head, int idx)
requires: ((sorted-sll^(head) & (locs^(head) s= hkss)) & (~ (head l= nil)));
ensures: ( (sorted-sll^(head) & (locs^(head) s= hkss)) &
	( ((ret l= nil) & (idx lt-set locs^(head))) |
	((~ (ret l= nil)) & ( (sorted-sll^(rn) & (idx lt-set locs^(rn))) * 
	((sorted-lseg^(head, ret) & ((lseg-locs^(head, ret) set-lt rk) & (rk <= idx))) * (ret |-> loc next: rn; int location: rk)) )) ) );



bb lookupprev-before-loop:
pre: ((sorted-sll^(head) & (locs^(head) s= hks)) & (~ (head l= nil)));
post: ( (sorted-sll^(head) & (locs^(head) s= hks)) & 
	( ((prev l= nil) & (head l= curr)) |
	((~ (prev l= nil)) & ( (sorted-sll^(curr) & (pk lt-set locs^(curr))) * 
	((sorted-lseg^(head, prev) & ((lseg-locs^(head, prev) set-lt pk) & (pk <= idx))) * (prev |-> loc next: curr; int location: pk)) )) ) );
{
	loc prev := nil;
	loc curr := head;
}

bb lookupprev-in-loop:
pre: ( (sorted-sll^(head) & (locs^(head) s= hks)) & 
	( ((prev l= nil) & (head l= curr)) |
	((~ (prev l= nil)) & ( (sorted-sll^(curr) & (pk lt-set locs^(curr))) * 
	((sorted-lseg^(head, prev) & ((lseg-locs^(head, prev) set-lt pk) & (pk <= idx))) * (prev |-> loc next: curr; int location: pk)) )) ) );
post: ( (sorted-sll^(head) & (locs^(head) s= hks)) & 
	( ((prev1 l= nil) & (head l= curr1)) |
	((~ (prev1 l= nil)) & ( (sorted-sll^(curr1) & (ck lt-set locs^(curr1))) * 
	((sorted-lseg^(head, prev1) & ((lseg-locs^(head, prev1) set-lt ck) & (ck <= idx))) * (prev1 |-> loc next: curr1; int location: ck)) )) ) );
{
	assume (! (curr l== nil));
	int ck := curr.location;
	assume (ck <= idx);
	loc prev1 := curr;
	loc curr1 := curr.next;
}

bb lookupprev-after-loop1:
pre: ( (sorted-sll^(head) & (locs^(head) s= hks)) & 
	( ((prev l= nil) & (head l= curr)) |
	((~ (prev l= nil)) & ( (sorted-sll^(curr) & (pk lt-set locs^(curr))) * 
	((sorted-lseg^(head, prev) & ((lseg-locs^(head, prev) set-lt pk) & (pk <= idx))) * (prev |-> loc next: curr; int location: pk)) )) ) );
post: ( (sorted-sll^(head) & (locs^(head) s= hks)) & 
	( ((ret l= nil) & (idx lt-set locs^(head))) |
	((~ (ret l= nil)) & ( (sorted-sll^(rn) & (idx lt-set locs^(rn))) * 
	((sorted-lseg^(head, ret) & ((lseg-locs^(head, ret) set-lt rk) & (rk <= idx))) * (ret |-> loc next: rn; int location: rk)) )) ) );
{
	assume (curr l== nil);
	loc rn := prev.next;
	int rk := prev.location;
	loc ret := prev;
}

bb lookupprev-after-loop2:
pre: ( (sorted-sll^(head) & (locs^(head) s= hks)) & 
	( ((prev l= nil) & (head l= curr)) |
	((~ (prev l= nil)) & ( (sorted-sll^(curr) & (pk lt-set locs^(curr))) * 
	((sorted-lseg^(head, prev) & ((lseg-locs^(head, prev) set-lt pk) & (pk <= idx))) * (prev |-> loc next: curr; int location: pk)) )) ) );
post: ( (sorted-sll^(head) & (locs^(head) s= hks)) & 
	( ((ret l= nil) & (idx lt-set locs^(head))) |
	((~ (ret l= nil)) & ( (sorted-sll^(rn) & (idx lt-set locs^(rn))) * 
	((sorted-lseg^(head, ret) & ((lseg-locs^(head, ret) set-lt rk) & (rk <= idx))) * (ret |-> loc next: rn; int location: rk)) )) ) );
{
	assume (! (curr l== nil));
	int ck := curr.location;
	assume (idx < ck);
	loc rn := prev.next;
	int rk := prev.location;
	loc ret := prev;
}

