define pred sll^(x): 
  ( 
	((x l= nil) & emp) | 
          ((x |-> loc next: nxt) * sll^(nxt))  
  ) ;
  
define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc next: nxt; int key: ky) * true): 
   	((singleton ky) union keys^(nxt));
   default: emptyset
  ) ;

method sll-insert(loc x, int k)
requires: (sll^(x) & (keys^(x) s= kk)) ;
ensures: (sll^(ret) & (keys^(ret) s= (kk union (singleton k)))) ;

bb insert-nil:
pre: (sll^(x) & (keys^(x) s= kk)) ;
post: (sll^(ret) & (keys^(ret) s= (kk union (singleton k)))) ;
{
	assume (x l== nil);
	malloc y;
	int y.key := k;
	loc ret := y; 
}

bb insert-recursive:
pre: (sll^(x) & (keys^(x) s= kk)) ;
post: (sll^(ret) & (keys^(ret) s= (kk union (singleton k)))) ;
{
	assume (! (x l== nil));
	loc y := x.next;
	loc t := sll-insert(y; k);
	loc x.next := t;
	loc ret := x;
}

bb insert-recursive-pre:
pre: (sll^(x) & (keys^(x) s= kk)) ;
post: (sll^(y) * true) ;
{
	assume (! (x l== nil));
	loc y := x.next;
}