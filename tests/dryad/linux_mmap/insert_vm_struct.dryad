define pred vma^(x): 
  ( ((x l= nil) & emp) |
	  (((x |-> loc left: lft; loc right: rgt; int start: st; int end: ed) & (st <= ed)) * 
	  ((vma^(lft) & (addrs^(lft) set-lt st)) * (vma^(rgt) & (ed lt-set addrs^(rgt)))))  
  )
  axiom: ((x l= nil) => (~ overlap^(x))) ;


define pred overlap^(x): 
  ( ((x l= nil) & true ) |
	  ((x |-> loc left: lft; loc right: rgt; int start: st; int end: ed) * 
	    (((st <= vmed) & (vmst <= ed)) | ((overlap^(lft) * true) | (overlap^(rgt) * true))))
  );

define set-fun addrs^(x):
  (case (x l= nil): emptyset;
  case ((x |-> loc left: lft; loc right: rgt; int start: st; int end: ed) * true): 
   	(((singleton st) union (singleton ed)) union (addrs^(lft) union addrs^(rgt)));
   default: emptyset
  ) ;

define relation vma-with-hole^(root, hole): 
  ( ((root l= hole) & emp) |
	 ( ((root |-> loc left: lft; loc right: rgt; int start: st; int end: ed) & (st <= ed)) * 
	   ( ((vmed < st) & ((vma-with-hole^(lft, hole) & (addrs-with-hole^(lft, hole) set-lt st)) * (vma^(rgt) & (ed lt-set addrs^(rgt))))) | 
	   ((ed < vmst) & ((vma^(lft) & (addrs^(lft) set-lt st)) * (vma-with-hole^(rgt, hole) & (ed lt-set addrs-with-hole^(rgt, hole))))) ) )
  )
  axiom: ( (vma^(hole) -* (((addrs-lt^(root, hole) lt addrs^(hole)) & (addrs^(hole) lt addrs-gt^(root, hole))) => (vma^(root) & (addrs^(root) s= (addrs-with-hole^(root, hole) union addrs^(hole)))))) &

	 ( ((((hole |-> loc left: virtual hl; loc right: virtual hr; int start: virtual hst; int end: virtual hed) & (hst <= hed)) * ((vmed < hst) & (vma^(hr) & (hed lt-set addrs^(hr))))) -* 
	  ( (((addrs-lt^(root, hole) set-lt hst) * true) & ((addrs^(hr) lt addrs-gt^(root, hole)) * true)) => 
	   ((vma-with-hole^(root, hl) & (addrs-with-hole^(root, hl) s= (addrs-with-hole^(root, hole) union (((singleton hst) union (singleton hed)) union addrs^(hr))))) &
	   ((addrs-gt^(root, hl) s= ((singleton hst) union addrs-gt^(root, hole))) & (addrs-lt^(root, hl) s= addrs-lt^(root, hole)))) )) &

	   ((((hole |-> loc left: virtual hl; loc right: virtual hr; int start: virtual hst; int end: virtual hed) & (hst <= hed)) * ((hed < vmst) & (vma^(hl) & (addrs^(hl) set-lt hst)))) -* 
	  ( (((addrs-lt^(root, hole) lt addrs^(hl)) * true) & ((hed lt-set addrs-gt^(root, hole)) * true)) => 
	   ((vma-with-hole^(root, hr) & (addrs-with-hole^(root, hr) s= (addrs-with-hole^(root, hole) union (((singleton hst) union (singleton hed)) union addrs^(hl))))) &
	   ((addrs-gt^(root, hr) s= addrs-gt^(root, hole)) & (addrs-lt^(root, hr) s= ((singleton hed) union addrs-lt^(root, hole))))) )) ) ) ;

define bin-set-fun addrs-with-hole^(root, hole):
  (case (root l= hole): emptyset;
   case ((root |-> loc left: lft; loc right: rgt; int start: st; int end: ed) * (vmed < st)): 
   	(((singleton st) union (singleton ed)) union (addrs-with-hole^(lft, hole) union addrs^(rgt)));
   case ((root |-> loc left: lft; loc right: rgt; int start: st; int end: ed) * (ed < vmst)): 
   	(((singleton st) union (singleton ed)) union (addrs^(lft) union addrs-with-hole^(rgt, hole)));
   default: emptyset
  ) ;

define bin-set-fun addrs-gt^(root, hole):
  (case (root l= hole): emptyset;
   case ((root |-> loc left: lft; loc right: rgt; int start: st; int end: ed) * (vmed < st)): 
   	((singleton st) union addrs-gt^(lft, hole));
   case ((root |-> loc left: lft; loc right: rgt; int start: st; int end: ed) * (ed < vmst)): 
   	addrs-gt^(rgt, hole);
   default: emptyset
  ) ;

define bin-set-fun addrs-lt^(root, hole):
  (case (root l= hole): emptyset;
   case ((root |-> loc left: lft; loc right: rgt; int start: st; int end: ed) * (vmed < st)): 
   	addrs-lt^(lft, hole);
   case ((root |-> loc left: lft; loc right: rgt; int start: st; int end: ed) * (ed < vmst)): 
   	((singleton ed) union addrs-lt^(rgt, hole));
   default: emptyset
  ) ;



bb vma-insert-nil:
pre: ((vma^(root) & (vmst <= vmed)) & ((addrs^(root) s= raddrs) & ((overlaped i= 0) <=> overlap^(root)))) ;
post: (vma^(ret) & 
       ( ((~ (overlaped i= 0)) & (addrs^(ret) s= (((singleton vmst) union (singleton vmed)) union raddrs))) |
       ((overlaped i= 0) & ((ret l= root) & (addrs^(ret) s= raddrs))) ) ) ;
{
	assume (root l== nil);
	malloc y;
	int y.start := vmst;
	int y.end := vmed;
	loc ret := y;
}

bb vma-insert-error:
pre: ((vma^(root) & (vmst <= vmed)) & ((addrs^(root) s= raddrs) & ((overlaped i= 0) <=> overlap^(root)))) ;
post: (vma^(ret) & 
       ( ((~ (overlaped i= 0)) & (addrs^(ret) s= (((singleton vmst) union (singleton vmed)) union raddrs))) |
       ((overlaped i= 0) & ((ret l= root) & (addrs^(ret) s= raddrs))) ) ) ;
{
	assume (! (root l== nil));
	int rst := root.start;
	int red := root.end;
	assume (! (vmed < rst));
	assume (! (red < vmst));
	loc ret := root;
}

bb vma-insert-before-loop1:
pre: ((vma^(root) & (vmst <= vmed)) & ((addrs^(root) s= raddrs) & ((overlaped i= 0) <=> overlap^(root)))) ;
post: ( (((vma-with-hole^(root, parent) & ((addrs-lt^(root, parent) set-lt vmst) & (vmed lt-set addrs-gt^(root, parent)))) * vma^(parent)) & (((addrs-lt^(root, parent) lt addrs^(parent)) & (addrs^(parent) lt addrs-gt^(root, parent))) & ((addrs^(parent) union addrs-with-hole^(root, parent)) s= raddrs))) &
	(((((parent |-> loc left: hole; int start: rst) * (vmed < rst)) | ((parent |-> loc right: hole; int end: red) * (red < vmst))) & (vmst <= vmed)) & ((overlaped i= 0) <=> overlap^(root))) ) ;
{
	assume (! (root l== nil));
	int rst := root.start;
	int red := root.end;
	assume (vmed < rst);
	loc parent := root;
	loc hole := root.left;
}

bb vma-insert-before-loop2:
pre: ((vma^(root) & (vmst <= vmed)) & ((addrs^(root) s= raddrs) & ((overlaped i= 0) <=> overlap^(root)))) ;
post: ( (((vma-with-hole^(root, parent) & ((addrs-lt^(root, parent) set-lt vmst) & (vmed lt-set addrs-gt^(root, parent)))) * vma^(parent)) & (((addrs-lt^(root, parent) lt addrs^(parent)) & (addrs^(parent) lt addrs-gt^(root, parent))) & ((addrs^(parent) union addrs-with-hole^(root, parent)) s= raddrs))) &
	(((((parent |-> loc left: hole; int start: rst) * (vmed < rst)) | ((parent |-> loc right: hole; int end: red) * (red < vmst))) & (vmst <= vmed)) & ((overlaped i= 0) <=> overlap^(root))) ) ;
{
	assume (! (root l== nil));
	int rst := root.start;
	int red := root.end;
	assume (! (vmed < rst));
	assume (red < vmst);
	loc parent := root;
	loc hole := root.right;
}

bb vma-insert-in-loop1:
pre: ( (((vma-with-hole^(root, parent) & ((addrs-lt^(root, parent) set-lt vmst) & (vmed lt-set addrs-gt^(root, parent)))) * vma^(parent)) & (((addrs-lt^(root, parent) lt addrs^(parent)) & (addrs^(parent) lt addrs-gt^(root, parent))) & ((addrs^(parent) union addrs-with-hole^(root, parent)) s= raddrs))) &
	(((((parent |-> loc left: hole; int start: pst) * (vmed < pst)) | ((parent |-> loc right: hole; int end: ped) * (ped < vmst))) & (vmst <= vmed)) & ((overlaped i= 0) <=> overlap^(root))) ) ;
post: ( (((vma-with-hole^(root, parent1) & ((addrs-lt^(root, parent1) set-lt vmst) & (vmed lt-set addrs-gt^(root, parent1)))) * vma^(parent1)) & (((addrs-lt^(root, parent1) lt addrs^(parent1)) & (addrs^(parent1) lt addrs-gt^(root, parent1))) & ((addrs^(parent1) union addrs-with-hole^(root, parent1)) s= raddrs))) &
	(((((parent1 |-> loc left: hole1; int start: pst1) * (vmed < pst1)) | ((parent1 |-> loc right: hole1; int end: ped1) * (ped1 < vmst))) & (vmst <= vmed)) & ((overlaped i= 0) <=> overlap^(root))) ) ;
{
	loc pl := parent.left;
	loc pr := parent.right;
	assume (! (hole l== nil));
	int pst1 := hole.start;
	int ped1 := hole.end;
	assume (vmed < pst1);
	loc parent1 := hole;
	loc hole1 := hole.left;
}

bb vma-insert-in-loop2:
pre: ( (((vma-with-hole^(root, parent) & ((addrs-lt^(root, parent) set-lt vmst) & (vmed lt-set addrs-gt^(root, parent)))) * vma^(parent)) & (((addrs-lt^(root, parent) lt addrs^(parent)) & (addrs^(parent) lt addrs-gt^(root, parent))) & ((addrs^(parent) union addrs-with-hole^(root, parent)) s= raddrs))) &
	(((((parent |-> loc left: hole; int start: pst) * (vmed < pst)) | ((parent |-> loc right: hole; int end: ped) * (ped < vmst))) & (vmst <= vmed)) & ((overlaped i= 0) <=> overlap^(root))) ) ;
post: ( (((vma-with-hole^(root, parent1) & ((addrs-lt^(root, parent1) set-lt vmst) & (vmed lt-set addrs-gt^(root, parent1)))) * vma^(parent1)) & (((addrs-lt^(root, parent1) lt addrs^(parent1)) & (addrs^(parent1) lt addrs-gt^(root, parent1))) & ((addrs^(parent1) union addrs-with-hole^(root, parent1)) s= raddrs))) &
	(((((parent1 |-> loc left: hole1; int start: pst1) * (vmed < pst1)) | ((parent1 |-> loc right: hole1; int end: ped1) * (ped1 < vmst))) & (vmst <= vmed)) & ((overlaped i= 0) <=> overlap^(root))) ) ;
{
	loc pl := parent.left;
	loc pr := parent.right;
	assume (! (hole l== nil));
	int pst1 := hole.start;
	int ped1 := hole.end;
	assume (! (vmed < pst1));
	assume (ped1 < vmst);
	loc parent1 := hole;
	loc hole1 := hole.right;
}


bb vma-insert-after-loop1:
pre: ( (((vma-with-hole^(root, parent) & ((addrs-lt^(root, parent) set-lt vmst) & (vmed lt-set addrs-gt^(root, parent)))) * vma^(parent)) & (((addrs-lt^(root, parent) lt addrs^(parent)) & (addrs^(parent) lt addrs-gt^(root, parent))) & ((addrs^(parent) union addrs-with-hole^(root, parent)) s= raddrs))) &
	(((((parent |-> loc left: hole; int start: pst) * (vmed < pst)) | ((parent |-> loc right: hole; int end: ped) * (ped < vmst))) & (vmst <= vmed)) & ((overlaped i= 0) <=> overlap^(root))) ) ;
post: (vma^(ret) & 
       ( ((~ (overlaped i= 0)) & (addrs^(ret) s= (((singleton vmst) union (singleton vmed)) union raddrs))) |
       ((overlaped i= 0) & ((ret l= root) & (addrs^(ret) s= raddrs))) ) ) ;
{
	assume (hole l== nil);
	int pst := parent.start;
	int ped := parent.end;
	assume (vmed < pst);
	malloc y;
	int y.start := vmst;
	int y.end := vmed;
	loc parent.left := y;
}

bb vma-insert-after-loop2:
pre: ( (((vma-with-hole^(root, parent) & ((addrs-lt^(root, parent) set-lt vmst) & (vmed lt-set addrs-gt^(root, parent)))) * vma^(parent)) & (((addrs-lt^(root, parent) lt addrs^(parent)) & (addrs^(parent) lt addrs-gt^(root, parent))) & ((addrs^(parent) union addrs-with-hole^(root, parent)) s= raddrs))) &
	(((((parent |-> loc left: hole; int start: pst) * (vmed < pst)) | ((parent |-> loc right: hole; int end: ped) * (ped < vmst))) & (vmst <= vmed)) & ((overlaped i= 0) <=> overlap^(root))) ) ;
post: (vma^(ret) & 
       ( ((~ (overlaped i= 0)) & (addrs^(ret) s= (((singleton vmst) union (singleton vmed)) union raddrs))) |
       ((overlaped i= 0) & ((ret l= root) & (addrs^(ret) s= raddrs))) ) ) ;
{
	assume (hole l== nil);
	int pst := parent.start;
	int ped := parent.end;
	assume (! (vmed < pst));
	assume (ped < vmst);
	malloc y;
	int y.start := vmst;
	int y.end := vmed;
	loc parent.right := y;
}

bb vma-insert-after-loop3:
pre: ( (((vma-with-hole^(root, parent) & ((addrs-lt^(root, parent) set-lt vmst) & (vmed lt-set addrs-gt^(root, parent)))) * vma^(parent)) & (((addrs-lt^(root, parent) lt addrs^(parent)) & (addrs^(parent) lt addrs-gt^(root, parent))) & ((addrs^(parent) union addrs-with-hole^(root, parent)) s= raddrs))) &
	(((((parent |-> loc left: hole; int start: pst) * (vmed < pst)) | ((parent |-> loc right: hole; int end: ped) * (ped < vmst))) & (vmst <= vmed)) & ((overlaped i= 0) <=> overlap^(root))) ) ;
post: (vma^(ret) & 
       ( ((~ (overlaped i= 0)) & (addrs^(ret) s= (((singleton vmst) union (singleton vmed)) union raddrs))) |
       ((overlaped i= 0) & ((ret l= root) & (addrs^(ret) s= raddrs))) ) ) ;
{
	assume (hole l== nil);
	int pst := parent.start;
	int ped := parent.end;
	assume (! (vmed < pst));
	assume (! (ped < vmst));
	loc ret := root;
}
