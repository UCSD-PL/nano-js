define pred vma^(x): 
  ( ((x l= nil) & emp) |
	  (((x |-> loc left: lft; loc right: rgt; int start: st; int end: ed) & (st <= ed)) * 
	  ((vma^(lft) & (addrs^(lft) set-lt st)) * (vma^(rgt) & (ed lt-set addrs^(rgt)))))  
  );


define pred contains-k^(x): 
  ( ((x l= nil) & (~ true) ) |
	  (((x |-> loc left: lft; loc right: rgt; int start: st; int end: ed) * ((((st <= k) & (k <= ed)) | contains-k^(lft)) | 
																					contains-k^(rgt))) * true)
  );

define set-fun addrs^(x):
  (case (x l= nil): emptyset;
  case ((x |-> loc left: lft; loc right: rgt; int start: st; int end: ed) * true): 
   	(((singleton st) union (singleton ed)) union (addrs^(lft) union addrs^(rgt)));
   default: emptyset
  ) ;

define relation vma-with-rightmost-hole^(root, hole):
  ( (((root l= hole) | (root l= nil)) & emp) |
         ( ((root |-> loc left: lft; loc right: rgt; int start: st; int end: ed) & (st <= ed))*
           ((vma^(lft) & (addrs^(lft) set-lt st)) * (vma-with-rightmost-hole^(rgt, hole) & (ed lt-set addrs-rightmost^(rgt, hole)))) )
  )
  axiom: ( (vma^(hole) -* ((addrs-rightmost^(root, hole) lt addrs^(hole)) => (vma^(root) & (addrs^(root) s= (addrs-rightmost^(root, hole) union addrs^(hole)))))) &

         ( (((hole |-> loc left: virtual hl; loc right: virtual hr; int start: virtual hst; int end: virtual hed) & (hst <= hed)) * (vma^(hl) & (addrs^(hl) set-lt hst))) -*
          (((addrs-rightmost^(root, hole) lt addrs^(hl)) * true) =>
           (vma-with-rightmost-hole^(root, hr) & (addrs-rightmost^(root, hr) s= (addrs-rightmost^(root, hole) union (((singleton hst) union (singleton hed)) union addrs^(hl)))))) ) ) ;


define bin-set-fun addrs-rightmost^(root, hole):
  (case ((root l= hole) | (root l= nil)): emptyset;
  case ((x |-> loc left: lft; loc right: rgt; int start: st; int end: ed) * true):
        (((singleton st) union (singleton ed)) union (addrs-rightmost^(rgt, hole) union addrs^(lft)));
   default: emptyset
  ) ;


bb loop-pre:
pre: (vma^(mm) & (addrset s= addrs^(mm)));
post: ((vma^(mm) & (addrset s= addrs^(mm))) & 
			   (((((parent l= nil) & (parent-left l= mm))  | ((parent |-> loc left: parent-left; int start: parent-st) * (k < parent-st))) *
			   (((vma-with-rightmost-hole^(parent-left, rbnode) & (addrs-rightmost^(parent-left, rbnode) set-lt k)) * vma^(rbnode)) &
						(addrs-rightmost^(parent-left, rbnode) lt addrs^(rbnode)))) &
			(contains-k^(mm) => (contains-k^(rbnode) * true))));
{
	loc rbnode := mm;
	loc parent := nil;
	loc parent-left := nil;
}

bb loop-post-contains-k:
pre: ((vma^(mm) & (addrset s= addrs^(mm))) & 
			   (((((parent l= nil) & (parent-left l= mm))  | ((parent |-> loc left: parent-left; int start: parent-st) * (k < parent-st))) *
			   (((vma-with-rightmost-hole^(parent-left, rbnode) & (addrs-rightmost^(parent-left, rbnode) set-lt k)) * vma^(rbnode)) &
						(addrs-rightmost^(parent-left, rbnode) lt addrs^(rbnode)))) &
			(contains-k^(mm) => (contains-k^(rbnode) * true))));

post: ((vma^(mm) & (addrset s= addrs^(mm))) & 
		  ((contains-k^(mm) & ((ret |-> int start: ret-st; int end: ret-ed) & ((ret-st <= k) & (k <= ret-ed)))) |
		  ((~ contains-k^(mm)) & (((ret l= nil) & (addrs^(mm) set-lt k)) |
								 (((ret |-> loc left: ret-lft; int start: ret-st) * (addrs^(ret-lft) set-lt k)) * (k < ret-st)))
		  )));
{
	assume (! (rbnode l== nil));
	loc parent-tmp := rbnode;
	int parent-tmp-end := parent-tmp.end;
	assume (k < parent-tmp-end);
	loc parent := parent-tmp;
	int parent-tmp-start := parent-tmp.start;
	assume (parent-tmp-start <= k);
	loc ret := parent;
	int ret-st := ret.start;
	int ret-ed := ret.end;
}


bb loop-inductive1:
pre: ((vma^(mm) & (addrset s= addrs^(mm))) & 
			   (((((parent l= nil) & (parent-left l= mm))  | ((parent |-> loc left: parent-left; int start: parent-st) * (k < parent-st))) *
			   (((vma-with-rightmost-hole^(parent-left, rbnode) & (addrs-rightmost^(parent-left, rbnode) set-lt k)) * vma^(rbnode)) &
						(addrs-rightmost^(parent-left, rbnode) lt addrs^(rbnode)))) &
			(contains-k^(mm) => (contains-k^(rbnode) * true))));

post: ((vma^(mm) & (addrset s= addrs^(mm))) & 
			   (((((parent l= nil) & (parent-left l= mm))  | ((parent |-> loc left: parent-left; int start: parent-st) * (k < parent-st))) *
			   (((vma-with-rightmost-hole^(parent-left, rbnode) & (addrs-rightmost^(parent-left, rbnode) set-lt k)) * vma^(rbnode)) &
						(addrs-rightmost^(parent-left, rbnode) lt addrs^(rbnode)))) &
			(contains-k^(mm) => (contains-k^(rbnode) * true))));
{
	assume (! (rbnode l== nil));
	loc parent-tmp := rbnode;
	int parent-tmp-end := parent-tmp.end;
	assume (k < parent-tmp-end);
	loc parent := parent-tmp;
	int parent-tmp-start := parent-tmp.start;
	assume (k < parent-tmp-start);
	loc rbnode-left := rbnode.left;
	loc rbnode := rbnode-left;
	loc parent-left := parent.left;
	int parent-st := parent.start;
}

bb loop-inductive2:
pre: ((vma^(mm) & (addrset s= addrs^(mm))) & 
			   (((((parent l= nil) & (parent-left l= mm))  | ((parent |-> loc left: parent-left; int start: parent-st) * (k < parent-st))) *
			   (((vma-with-rightmost-hole^(parent-left, rbnode) & (addrs-rightmost^(parent-left, rbnode) set-lt k)) * vma^(rbnode)) &
						(addrs-rightmost^(parent-left, rbnode) lt addrs^(rbnode)))) &
			(contains-k^(mm) => (contains-k^(rbnode) * true))));

post: ((vma^(mm) & (addrset s= addrs^(mm))) & 
			   (((((parent l= nil) & (parent-left l= mm))  | ((parent |-> loc left: parent-left; int start: parent-st) * (k < parent-st))) *
			   (((vma-with-rightmost-hole^(parent-left, rbnode) & (addrs-rightmost^(parent-left, rbnode) set-lt k)) * vma^(rbnode)) &
						(addrs-rightmost^(parent-left, rbnode) lt addrs^(rbnode)))) &
			(contains-k^(mm) => (contains-k^(rbnode) * true))));
{
	assume (! (rbnode l== nil));
	loc parent-tmp := rbnode;
	int parent-tmp-end := parent-tmp.end;
	assume (parent-tmp-end <= k);
	loc rbnode-right := rbnode.right;
	loc rbnode := rbnode-right;
	loc parent-left := parent.left;
	int parent-st := parent.start;
}


bb loop-post-not-contains-k1:
pre: ((vma^(mm) & (addrset s= addrs^(mm))) & 
			   (((((parent l= nil) & (parent-left l= mm))  | ((parent |-> loc left: parent-left; int start: parent-st) * (k < parent-st))) *
			   (((vma-with-rightmost-hole^(parent-left, rbnode) & (addrs-rightmost^(parent-left, rbnode) set-lt k)) * vma^(rbnode)) &
						(addrs-rightmost^(parent-left, rbnode) lt addrs^(rbnode)))) &
			(contains-k^(mm) => (contains-k^(rbnode) * true))));

post: ((vma^(mm) & (addrset s= addrs^(mm))) & 
		  ((contains-k^(mm) & ((ret |-> int start: ret-st; int end: ret-ed) & ((ret-st <= k) & (k <= ret-ed)))) |
		  ((~ contains-k^(mm)) & (((ret l= nil) & (addrs^(mm) set-lt k)) |
								 (((ret |-> loc left: ret-lft; int start: ret-st) * (addrs^(ret-lft) set-lt k)) * (k < ret-st)))
		  )));
{
	assume (rbnode l== nil);
	loc ret := parent;
	assume (! (ret l== nil));
	int ret-st := ret.start;
	int ret-ed := ret.end;
	loc ret-lft := ret.left;
}


bb loop-post-not-contains-k2:
pre: ((vma^(mm) & (addrset s= addrs^(mm))) & 
			   (((((parent l= nil) & (parent-left l= mm))  | ((parent |-> loc left: parent-left; int start: parent-st) * (k < parent-st))) *
			   (((vma-with-rightmost-hole^(parent-left, rbnode) & (addrs-rightmost^(parent-left, rbnode) set-lt k)) * vma^(rbnode)) &
						(addrs-rightmost^(parent-left, rbnode) lt addrs^(rbnode)))) &
			(contains-k^(mm) => (contains-k^(rbnode) * true))));

post: ((vma^(mm) & (addrset s= addrs^(mm))) & 
		  ((contains-k^(mm) & ((ret |-> int start: ret-st; int end: ret-ed) & ((ret-st <= k) & (k <= ret-ed)))) |
		  ((~ contains-k^(mm)) & (((ret l= nil) & (addrs^(mm) set-lt k)) |
								 (((ret |-> loc left: ret-lft; int start: ret-st) * (addrs^(ret-lft) set-lt k)) * (k < ret-st)))
		  )));
{
	assume (rbnode l== nil);
	loc ret := parent;
	assume (ret l== nil);
}