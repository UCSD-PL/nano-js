define pred treap^(x): 
  ( ((x l= nil) & emp) |
    (
        (x |-> loc left: lft; loc right: rgt; int key: ky; int priority: pt) * 
        (
	 (
	  (treap^(lft) & ((keys^(lft) set-lt ky) & (priorities^(lft) set-lt pt))) *
	  (treap^(rgt) & ((ky lt-set keys^(rgt)) & (priorities^(rgt) set-lt pt)))
	 ) & 
	 ((priorities^(lft) intersection priorities^(rgt)) s= emptyset)
	)
    )
  ) ;

define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int key: ky) * true): 
   	((singleton ky) union (keys^(lft) union keys^(rgt)));
   default: emptyset
  ) ;

define set-fun priorities^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int priority: pt) * true): 
   	((singleton pt) union (priorities^(lft) union priorities^(rgt)));
   default: emptyset
  ) ;

method treap-search(loc x, int kk)
requires: (treap^(x) & (keys^(x) s= xks)) ;
ensures: (((ret i= 1) & (kk i-in xks)) | ((ret i= 0) & (~ (kk i-in xks)))) ;


bb treap-search-nil:
pre: (treap^(x) & (keys^(x) s= xkss)) ;
post: (((ret i= 1) & (k i-in xkss)) | ((ret i= 0) & (~ (k i-in xkss)))) ;
{
	assume (x l== nil);
	int ret := 0;
}

bb treap-search-basic:
pre: (treap^(x) & (keys^(x) s= xkss)) ;
post: (((ret i= 1) & (k i-in xkss)) | ((ret i= 0) & (~ (k i-in xkss)))) ;
{
	assume (! (x l== nil));
	int xk := x.key;
	assume (k i== xk);
	int ret := 1;
}

bb treap-search-left-pre:
pre: (treap^(x) & (keys^(x) s= xkss)) ;
post: (treap^(l) * true) ;
{
	assume (! (x l== nil));
	int xk := x.key;
	loc l := x.left;
	assume (! (k i== xk));
	assume (k < xk);
}

bb treap-search-right-pre:
pre: (treap^(x) & (keys^(x) s= xkss)) ;
post: (treap^(r) * true) ;
{
	assume (! (x l== nil));
	int xk := x.key;
	loc r := x.right;
	assume (! (k i== xk));
	assume (! (k < xk));
}

bb treap-search-left:
pre: (treap^(x) & (keys^(x) s= xkss)) ;
post: (((ret i= 1) & (k i-in xkss)) | ((ret i= 0) & (~ (k i-in xkss)))) ;
{
	assume (! (x l== nil));
	int xk := x.key;
	loc l := x.left;
	assume (! (k i== xk));
	assume (k < xk);
	int ret := treap-search(l; k);
}

bb treap-search-right:
pre: (treap^(x) & (keys^(x) s= xkss)) ;
post: (((ret i= 1) & (k i-in xkss)) | ((ret i= 0) & (~ (k i-in xkss)))) ;
{
	assume (! (x l== nil));
	int xk := x.key;
	loc r := x.right;
	assume (! (k i== xk));
	assume (! (k < xk));
	int ret := treap-search(r; k);
}


