define pred treap^(x): 
  ( ((x l= nil) & emp) |
    (
        (x |-> loc left: lft; loc right: rgt; int key: ky; int priority: pt) * 
        (
	 (
	  (treap^(lft) & ((keys^(lft) set-lt ky) & (priorities^(lft) set-lt pt))) *
	  (treap^(rgt) & ((ky lt-set keys^(rgt)) & (priorities^(rgt) set-lt pt)))
	 ) & 
	 ((priorities^(lft) intersection priorities^(rgt)) s= emptyset)
	)
    )
  ) ;

define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int key: ky) * true): 
   	((singleton ky) union (keys^(lft) union keys^(rgt)));
   default: emptyset
  ) ;

define set-fun priorities^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int priority: pt) * true): 
   	((singleton pt) union (priorities^(lft) union priorities^(rgt)));
   default: emptyset
  ) ;

method treap-removeroot(loc x)
requires: (
        	((x |-> loc left: lft; loc right: rgt; int key: ky; int priority: pt) * 
        	(
	 	 (treap^(lft) & ((keys^(lft) s= lks) & (priorities^(lft) s= lpts))) * 
	 	 (treap^(rgt) & ((keys^(rgt) s= rks) & (priorities^(rgt) s= rpts)))
		)) &
		((lks lt rks) & ((lpts intersection rpts) s= emptyset))
    ) ;
ensures: (treap^(ret) & ((keys^(ret) s= (lks union rks)) & (priorities^(ret) s= (lpts union rpts)))) ;

method treap-delete(loc x, int kk)
requires: (((treap^(x) & (keys^(x) s= xks)) & (priorities^(x) s= xpts)) &
	(kk i-in xks)) ;
ensures: ((treap^(ret) & (keys^(ret) s= (xks setminus (singleton kk)))) & 
	  (priorities^(ret) s-subset xpts)) ; 


bb treap-delete-current-pre:
pre: (((treap^(x) & (keys^(x) s= xkss)) & (priorities^(x) s= xptss)) &
	(k i-in xkss)) ;
post: (
        ((x |-> loc left: xl; loc right: xr; int key: xk; int priority: xpt) * 
        ((treap^(xl) * treap^(xr)) &
	((keys^(xl) lt keys^(xr)) & ((priorities^(xl) intersection priorities^(xr)) s= emptyset))))
    * true);
{
	loc xl := x.left;
	loc xr := x.right;
	int xk := x.key;
	int xpt := x.priority;
	assume (xk i== k);
}

bb treap-delete-current:
pre: (((treap^(x) & (keys^(x) s= xkss)) & (priorities^(x) s= xptss)) &
	(k i-in xkss)) ;
post: ((treap^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	  (priorities^(ret) s-subset xptss)) ; 
{
	loc xl := x.left;
	loc xr := x.right;
	int xk := x.key;
	int xpt := x.priority;
	assume (xk i== k);
	loc ret := treap-removeroot(x);
}

bb treap-delete-left-pre:
pre: (((treap^(x) & (keys^(x) s= xkss)) & (priorities^(x) s= xptss)) &
	(k i-in xkss)) ;
post: (
        ((xl |-> loc left: xll; loc right: xlr; int key: xlk; int priority: xlpt) * 
        ((treap^(xll) * treap^(xlr)) &
	((keys^(xll) lt keys^(xlr)) & ((priorities^(xll) intersection priorities^(xlr)) s= emptyset))))
    * true);
{
	loc xl := x.left;
	loc xr := x.right;
	int xk := x.key;
	int xpt := x.priority;
	assume (! (xk i== k));
	assume (k < xk);
	loc xll := xl.left;
	loc xlr := xl.right;
	int xlk := xl.key;
	int xlpt := xl.priority;
}

bb treap-delete-right-pre:
pre: (((treap^(x) & (keys^(x) s= xkss)) & (priorities^(x) s= xptss)) &
	(k i-in xkss)) ;
post: (
        ((xr |-> loc left: xrl; loc right: xrr; int key: xrk; int priority: xrpt) * 
        ((treap^(xrl) * treap^(xrr)) &
	((keys^(xrl) lt keys^(xrr)) & ((priorities^(xrl) intersection priorities^(xrr)) s= emptyset))))
    * true);
{
	loc xl := x.left;
	loc xr := x.right;
	int xk := x.key;
	int xpt := x.priority;
	assume (! (xk i== k));
	assume (! (k < xk));
	loc xrl := xr.left;
	loc xrr := xr.right;
	int xrk := xr.key;
	int xrpt := xr.priority;
}

bb treap-delete-left:
pre: (((treap^(x) & (keys^(x) s= xkss)) & (priorities^(x) s= xptss)) &
	(k i-in xkss)) ;
post: ((treap^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	  (priorities^(ret) s-subset xptss)) ; 
{
	loc xl := x.left;
	loc xr := x.right;
	int xk := x.key;
	int xpt := x.priority;
	assume (! (xk i== k));
	assume (k < xk);
	loc t := treap-delete(xl; k);
	loc x.left := t;
	loc ret := x;
}

bb treap-delete-right:
pre: (((treap^(x) & (keys^(x) s= xkss)) & (priorities^(x) s= xptss)) &
	(k i-in xkss)) ;
post: ((treap^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	  (priorities^(ret) s-subset xptss)) ; 
{
	loc xl := x.left;
	loc xr := x.right;
	int xk := x.key;
	int xpt := x.priority;
	assume (! (xk i== k));
	assume (! (k < xk));
	loc t := treap-delete(xr; k);
	loc x.right := t;
	loc ret := x;
}


