define pred treap^(x): 
  ( ((x l= nil) & emp) |
    (
        (x |-> loc left: lft; loc right: rgt; int key: ky; int priority: pt) * 
        (
	 (
	  (treap^(lft) & ((keys^(lft) set-lt ky) & (priorities^(lft) set-lt pt))) *
	  (treap^(rgt) & ((ky lt-set keys^(rgt)) & (priorities^(rgt) set-lt pt)))
	 ) & 
	 ((priorities^(lft) intersection priorities^(rgt)) s= emptyset)
	)
    )
  ) ;

define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int key: ky) * true): 
   	((singleton ky) union (keys^(lft) union keys^(rgt)));
   default: emptyset
  ) ;

define set-fun priorities^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int priority: pt) * true): 
   	((singleton pt) union (priorities^(lft) union priorities^(rgt)));
   default: emptyset
  ) ;

method treap-insert(loc x, int k, int p)
requires: ((treap^(x) & ((keys^(x) s= xks) & (priorities^(x) s= xpts))) & (~ ((k i-in xks) | (p i-in xpts)))) ;
ensures: (treap^(ret) & ((keys^(ret) s= (xks union (singleton k))) & (priorities^(ret) s= (xpts union (singleton p))))) ;


bb treap-insert-basic:
pre: ((treap^(x) & ((keys^(x) s= xkss) & (priorities^(x) s= xptss))) & (~ ((k i-in xkss) | (p i-in xptss)))) ;
post: (treap^(ret) & ((keys^(ret) s= (xkss union (singleton k))) & (priorities^(ret) s= (xptss union (singleton p))))) ;
{
	assume (x l== nil);
	malloc y;
	int y.key := k;
	int y.priority := p;
	loc ret := y;
}

bb treap-insert-left-pre:
pre: ((treap^(x) & ((keys^(x) s= xkss) & (priorities^(x) s= xptss))) & (~ ((k i-in xkss) | (p i-in xptss)))) ;
post: ((treap^(l) & (~ ((k i-in keys^(l)) | (p i-in priorities^(l))))) * true) ;
{
	assume (! (x l== nil));
	int xk := x.key;
	loc l := x.left;
	assume (k < xk);
}

bb treap-insert-right-pre:
pre: ((treap^(x) & ((keys^(x) s= xkss) & (priorities^(x) s= xptss))) & (~ ((k i-in xkss) | (p i-in xptss)))) ;
post: ((treap^(r) & (~ ((k i-in keys^(r)) | (p i-in priorities^(r))))) * true) ;
{
	assume (! (x l== nil));
	int xk := x.key;
	loc r := x.right;
	assume (! (k < xk));
}

bb treap-insert-left1:
pre: ((treap^(x) & ((keys^(x) s= xkss) & (priorities^(x) s= xptss))) & (~ ((k i-in xkss) | (p i-in xptss)))) ;
post: (treap^(ret) & ((keys^(ret) s= (xkss union (singleton k))) & (priorities^(ret) s= (xptss union (singleton p))))) ;
{
	assume (! (x l== nil));
	int xk := x.key;
	int xp := x.priority;
	loc l := x.left;
	assume (k < xk);
	loc t := treap-insert(l; k, p);
	int tp := t.priority;
	assume (tp <= xp);
	loc x.left := t;
	loc ret := x;
}

bb treap-insert-left2:
pre: ((treap^(x) & ((keys^(x) s= xkss) & (priorities^(x) s= xptss))) & (~ ((k i-in xkss) | (p i-in xptss)))) ;
post: (treap^(ret) & ((keys^(ret) s= (xkss union (singleton k))) & (priorities^(ret) s= (xptss union (singleton p))))) ;
{
	assume (! (x l== nil));
	int xk := x.key;
	int xp := x.priority;
	loc l := x.left;
	assume (k < xk);
	loc t := treap-insert(l; k, p);
	int tp := t.priority;
	assume (! (tp <= xp));
	loc lr := t.right;
	loc x.left := lr;
	loc t.right := x;
	loc ret := t;
}

bb treap-insert-right1:
pre: ((treap^(x) & ((keys^(x) s= xkss) & (priorities^(x) s= xptss))) & (~ ((k i-in xkss) | (p i-in xptss)))) ;
post: (treap^(ret) & ((keys^(ret) s= (xkss union (singleton k))) & (priorities^(ret) s= (xptss union (singleton p))))) ;
{
	assume (! (x l== nil));
	int xk := x.key;
	int xp := x.priority;
	loc r := x.right;
	assume (! (k < xk));
	loc t := treap-insert(r; k, p);
	int tp := t.priority;
	assume (tp <= xp);
	loc x.right := t;
	loc ret := x;
}

bb treap-insert-right2:
pre: ((treap^(x) & ((keys^(x) s= xkss) & (priorities^(x) s= xptss))) & (~ ((k i-in xkss) | (p i-in xptss)))) ;
post: (treap^(ret) & ((keys^(ret) s= (xkss union (singleton k))) & (priorities^(ret) s= (xptss union (singleton p))))) ;
{
	assume (! (x l== nil));
	int xk := x.key;
	int xp := x.priority;
	loc r := x.right;
	assume (! (k < xk));
	loc t := treap-insert(r; k, p);
	int tp := t.priority;
	assume (! (tp <= xp));
	loc rl := t.left;
	loc x.right := rl;
	loc t.left := x;
	loc ret := t;
}


