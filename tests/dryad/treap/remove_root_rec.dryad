define pred treap^(x): 
  ( ((x l= nil) & emp) |
    (
        (x |-> loc left: lft; loc right: rgt; int key: ky; int priority: pt) * 
        (
	 (
	  (treap^(lft) & ((keys^(lft) set-lt ky) & (priorities^(lft) set-lt pt))) *
	  (treap^(rgt) & ((ky lt-set keys^(rgt)) & (priorities^(rgt) set-lt pt)))
	 ) & 
	 ((priorities^(lft) intersection priorities^(rgt)) s= emptyset)
	)
    )
  ) ;

define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int key: ky) * true): 
   	((singleton ky) union (keys^(lft) union keys^(rgt)));
   default: emptyset
  ) ;

define set-fun priorities^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int priority: pt) * true): 
   	((singleton pt) union (priorities^(lft) union priorities^(rgt)));
   default: emptyset
  ) ;

method treap-removeroot(loc x)
requires: (
        	((x |-> loc left: lft; loc right: rgt; int key: ky; int priority: pt) * 
        	(
	 	 (treap^(lft) & ((keys^(lft) s= lks) & (priorities^(lft) s= lpts))) * 
	 	 (treap^(rgt) & ((keys^(rgt) s= rks) & (priorities^(rgt) s= rpts)))
		)) &
		((lks lt rks) & ((lpts intersection rpts) s= emptyset))
    );
ensures: (treap^(ret) & ((keys^(ret) s= (lks union rks)) & (priorities^(ret) s= (lpts union rpts)))) ;


bb treap-removeroot-nil-leftright:
pre: (
        	((x |-> loc left: xlft; loc right: xrgt; int key: xky; int priority: xpt) * 
        	(
	 	 (treap^(xlft) & ((keys^(xlft) s= lkss) & (priorities^(xlft) s= lptss))) * 
	 	 (treap^(xrgt) & ((keys^(xrgt) s= rkss) & (priorities^(xrgt) s= rptss)))
		)) &
		((lkss lt rkss) & ((lptss intersection rptss) s= emptyset))
    );
post: (treap^(ret) & ((keys^(ret) s= (lkss union rkss)) & (priorities^(ret) s= (lptss union rptss)))) ;
{
	loc xl := x.left;
	loc xr := x.right;
	assume ((xl l== nil) && (xr l== nil));
	free x;
	loc ret := nil;
}

bb treap-removeroot-nil-left:
pre: (
        	((x |-> loc left: xlft; loc right: xrgt; int key: xky; int priority: xpt) * 
        	(
	 	 (treap^(xlft) & ((keys^(xlft) s= lkss) & (priorities^(xlft) s= lptss))) * 
	 	 (treap^(xrgt) & ((keys^(xrgt) s= rkss) & (priorities^(xrgt) s= rptss)))
		)) &
		((lkss lt rkss) & ((lptss intersection rptss) s= emptyset))
    );
post: (treap^(ret) & ((keys^(ret) s= (lkss union rkss)) & (priorities^(ret) s= (lptss union rptss)))) ;
{
	loc xl := x.left;
	loc xr := x.right;
	assume ((xl l== nil) && (! (xr l== nil)));
	free x;
	loc ret := xr;
}

bb treap-removeroot-nil-right:
pre: (
        	((x |-> loc left: xlft; loc right: xrgt; int key: xky; int priority: xpt) * 
        	(
	 	 (treap^(xlft) & ((keys^(xlft) s= lkss) & (priorities^(xlft) s= lptss))) * 
	 	 (treap^(xrgt) & ((keys^(xrgt) s= rkss) & (priorities^(xrgt) s= rptss)))
		)) &
		((lkss lt rkss) & ((lptss intersection rptss) s= emptyset))
    );
post: (treap^(ret) & ((keys^(ret) s= (lkss union rkss)) & (priorities^(ret) s= (lptss union rptss)))) ;
{
	loc xl := x.left;
	loc xr := x.right;
	assume ((! (xl l== nil)) && (xr l== nil));
	free x;
	loc ret := xl;
}

bb treap-removeroot-right-pre:
pre: (
        	((x |-> loc left: xlft; loc right: xrgt; int key: xky; int priority: xpt) * 
        	(
	 	 (treap^(xlft) & ((keys^(xlft) s= lkss) & (priorities^(xlft) s= lptss))) * 
	 	 (treap^(xrgt) & ((keys^(xrgt) s= rkss) & (priorities^(xrgt) s= rptss)))
		)) &
		((lkss lt rkss) & ((lptss intersection rptss) s= emptyset))
    );
post: (
        ((x |-> loc left: xl; loc right: xrl; int key: xky; int priority: xpt) * 
        ((treap^(xl) * treap^(xrl)) &
	((keys^(xl) lt keys^(xrl)) & ((priorities^(xl) intersection priorities^(xrl)) s= emptyset))))
    * true);
{
	loc xl := x.left;
	loc xr := x.right;
	assume ((! (xl l== nil)) && (! (xr l== nil)));
	int xlpt := xl.priority;
	int xrpt := xr.priority;
	assume (xlpt <= xrpt);
	loc xrl := xr.left;
	loc x.right := xrl;
}

bb treap-removeroot-left-pre:
pre: (
        	((x |-> loc left: xlft; loc right: xrgt; int key: xky; int priority: xpt) * 
        	(
	 	 (treap^(xlft) & ((keys^(xlft) s= lkss) & (priorities^(xlft) s= lptss))) * 
	 	 (treap^(xrgt) & ((keys^(xrgt) s= rkss) & (priorities^(xrgt) s= rptss)))
		)) &
		((lkss lt rkss) & ((lptss intersection rptss) s= emptyset))
    );
post: (
        ((x |-> loc left: xlr; loc right: xr; int key: xky; int priority: xpt) * 
        ((treap^(xlr) * treap^(xr)) &
	((keys^(xlr) lt keys^(xr)) & ((priorities^(xlr) intersection priorities^(xr)) s= emptyset))))
    * true);
{
	loc xl := x.left;
	loc xr := x.right;
	assume ((! (xl l== nil)) && (! (xr l== nil)));
	int xlpt := xl.priority;
	int xrpt := xr.priority;
	assume (! (xlpt <= xrpt));
	loc xlr := xl.right;
	loc x.left := xlr;
}

bb treap-removeroot-right:
pre: (
        	((x |-> loc left: xlft; loc right: xrgt; int key: xky; int priority: xpt) * 
        	(
	 	 (treap^(xlft) & ((keys^(xlft) s= lkss) & (priorities^(xlft) s= lptss))) * 
	 	 (treap^(xrgt) & ((keys^(xrgt) s= rkss) & (priorities^(xrgt) s= rptss)))
		)) &
		((lkss lt rkss) & ((lptss intersection rptss) s= emptyset))
    );
post: (treap^(ret) & ((keys^(ret) s= (lkss union rkss)) & (priorities^(ret) s= (lptss union rptss)))) ;
{
	loc xl := x.left;
	loc xr := x.right;
	assume ((! (xl l== nil)) && (! (xr l== nil)));
	int xlpt := xl.priority;
	int xrpt := xr.priority;
	assume (xlpt <= xrpt);
	loc xrl := xr.left;
	loc x.right := xrl;
	loc t := treap-removeroot(x);
	loc xr.left := t;
	loc ret := xr;
}

bb treap-removeroot-left:
pre: (
        	((x |-> loc left: xlft; loc right: xrgt; int key: xky; int priority: xpt) * 
        	(
	 	 (treap^(xlft) & ((keys^(xlft) s= lkss) & (priorities^(xlft) s= lptss))) * 
	 	 (treap^(xrgt) & ((keys^(xrgt) s= rkss) & (priorities^(xrgt) s= rptss)))
		)) &
		((lkss lt rkss) & ((lptss intersection rptss) s= emptyset))
    );
post: (treap^(ret) & ((keys^(ret) s= (lkss union rkss)) & (priorities^(ret) s= (lptss union rptss)))) ;
{
	loc xl := x.left;
	loc xr := x.right;
	assume ((! (xl l== nil)) && (! (xr l== nil)));
	int xlpt := xl.priority;
	int xrpt := xr.priority;
	assume (! (xlpt <= xrpt));
	loc xlr := xl.right;
	loc x.left := xlr;
	loc t := treap-removeroot(x);
	loc xl.right := t;
	loc ret := xl;
}


