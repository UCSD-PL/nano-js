define pred avl^(x): 
  ( ((x l= nil) & emp) |
    (
        (x |-> loc left: lft; loc right: rgt; int key: ky; int hight: hgt) * 
        (
	 (
	  (avl^(lft) & (keys^(lft) set-lt ky)) *
	  (avl^(rgt) & (ky lt-set keys^(rgt)))
	 ) &
	 (
	  ((height^(lft) i= height^(rgt)) & ((hgt i= (height^(lft) + 1)) * true)) 	   |
	  ( ((height^(lft) i= (height^(rgt) + 1)) & ((hgt i= (height^(rgt) + 2)) * true) ) |
	  ((height^(rgt) i= (height^(lft) + 1)) & ((hgt i= (height^(lft) + 2)) * true) ) )
	)
       )
    )
  ) ;

define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int key: ky; int hight: hgt) * true): 
   	((singleton ky) union (keys^(lft) union keys^(rgt)));
   default: emptyset
  ) ;

define int-fun height^(x):
  (case (x l= nil): 0;
   case (((x |-> loc left: lft; loc right: rgt; int key: ky; int hight: hgt) * true) &
	((height^(lft) < height^(rgt)) * true)): 
   	(height^(rgt) + 1);
   default: (height^(lft) + 1)
  ) ;

method avl-find-smallest(loc x)
requires: ((((avl^(x) & (keys^(x) s= xks2)) & (height^(x) i= h2)) & (~ (x l= nil)))
       	& ((xks2 s= ((singleton minn) union rest)) & (minn lt-set rest))) ;
ensures: (((avl^(x) & (keys^(x) s= xks2)) & (height^(x) i= h2)) & (ret i= minn)) ;

bb avl-find-smallest-base:
pre: ((((avl^(x) & (keys^(x) s= xkss)) & (height^(x) i= hh)) & (~ (x l= nil)))
       	& ((xkss s= ((singleton minn) union restt)) & (minn lt-set restt))) ;
post: (((avl^(x) & (keys^(x) s= xkss)) & (height^(x) i= hh)) & (ret i= minn)) ;
{
	loc xl := x.left;
	int xk := x.key;
	assume (xl l== nil);
	int ret := xk;
}

bb avl-find-smallest-recursive-pre:
pre: ((((avl^(x) & (keys^(x) s= xkss)) & (height^(x) i= hh)) & (~ (x l= nil)))
       	& ((xkss s= ((singleton minn) union restt)) & (minn lt-set restt))) ;
post: ((avl^(xl) & (~ (xl l= nil))) * true) ;
{
	loc xl := x.left;
	int xk := x.key;
	assume (! (xl l== nil));
}

bb avl-find-smallest-recursive:
pre: ((((avl^(x) & (keys^(x) s= xkss)) & (height^(x) i= hh)) & (~ (x l= nil)))
       	& ((xkss s= ((singleton minn) union restt)) & (minn lt-set restt))) ;
post: (((avl^(x) & (keys^(x) s= xkss)) & (height^(x) i= hh)) & (ret i= minn)) ;
{
	loc xl := x.left;
	int xk := x.key;
	assume (! (xl l== nil));
	int ret := avl-find-smallest(xl);
}
