define pred rbp^(x): 
  ( ((x l= nil) & emp) |
    (
      (
        (x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * 
        (
	 (
	  (rbp^(lft) & (keys^(lft) set-lt ky)) *
	  (rbp^(rgt) & (ky lt-set keys^(rgt)))
	 ) &
	 (bh^(lft) i= bh^(rgt))
       )
     ) &
     ((clr i= 0) |
      ((black^(lft) * true) & (black^(rgt) * true))
     )  
   )
  ) ;

define pred black^(x):
	( ((x l= nil) & emp) | ((x |-> int color: clr) & (clr i= 0)) ) ;

define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true): 
   	((singleton ky) union (keys^(lft) union keys^(rgt)));
   default: emptyset
  ) ;

define int-fun bh^(x):
  (case (x l= nil): 1;
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(lft) < bh^(rgt)) * true)) & (clr i= 0)): 
   	(bh^(rgt) + 1);
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(lft) < bh^(rgt)) * true)) & (~ (clr i= 0))): 
   	bh^(rgt);
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(rgt) <= bh^(lft)) * true)) & (clr i= 0)): 
   	(bh^(lft) + 1);
   default: bh^(lft)
  ) ;


method rbt-delete-left-fixup(loc x)
requires: (
    (
     (
        (x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * 
	 (
	  (rbp^(lft) & (keys^(lft) set-lt ky)) *
	  (rbp^(rgt) & (ky lt-set keys^(rgt)))
	 )
     ) & 
     ((((bh^(lft) + 1) i= bh^(rgt)) * true) & ((black^(lft) * true) & ((clr i= 0) | (black^(rgt) * true))))
   ) & (((keys^(x) s= xks2) & (bh^(x) i= h2)) & (((black^(x) * true) & (oldclr i= 0)) | (((~ black^(x)) * true) & (~ (oldclr i= 0)))))
    ) ;
ensures: ( 
	( (rbp^(ret) & (keys^(ret) s= xks2)) &
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (oldclr i= 0)))) ) &
	( ((~ (post-fixed i= 0)) & (bh^(ret) i= h2)) |
	((post-fixed i= 0) & ((oldclr i= 0) & (bh^(ret) i= (h2 - 1)))) )
	) ;


bb rbt-delete-left-fixup-case2-pre:
pre: (
    (
     (
        (x |-> loc left: xlft; loc right: xrgt; int key: xky; int color: xclr) * 
	 (
	  (rbp^(xlft) & (keys^(xlft) set-lt xky)) *
	  (rbp^(xrgt) & (xky lt-set keys^(xrgt)))
	 )
     ) & 
     ((((bh^(xlft) + 1) i= bh^(xrgt)) * true) & ((black^(xlft) * true) & ((xclr i= 0) | (black^(xrgt) * true))))
   ) & (((keys^(x) s= xkss) & (bh^(x) i= hh)) & (((black^(x) * true) & (oldclrr i= 0)) | (((~ black^(x)) * true) & (~ (oldclrr i= 0)))))
    ) ;
post: (
    (
     (
        (x |-> loc left: xl; loc right: xrl; int key: xkey; int color: one) * 
	 (
	  (rbp^(xl) & (keys^(xl) set-lt xkey)) *
	  (rbp^(xrl) & (xkey lt-set keys^(xrl)))
	 )
     ) & 
     ((((bh^(xl) + 1) i= bh^(xrl)) * true) & ((black^(xl) * true) & ((one i= 0) | (black^(xrl) * true))))
   ) * true
    ) ;
{
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	int xrcolor := xr.color;
	assume (! (xrcolor i== 0));
	loc xrl := xr.left;
	loc x.right := xrl;
	loc xr.left := x;
	int one := 1;
	int zero := 0;
	int x.color := one;
	int xr.color := zero;
}

bb rbt-delete-left-fixup-case2:
pre: (
    (
     (
        (x |-> loc left: xlft; loc right: xrgt; int key: xky; int color: xclr) * 
	 (
	  (rbp^(xlft) & (keys^(xlft) set-lt xky)) *
	  (rbp^(xrgt) & (xky lt-set keys^(xrgt)))
	 )
     ) & 
     ((((bh^(xlft) + 1) i= bh^(xrgt)) * true) & ((black^(xlft) * true) & ((xclr i= 0) | (black^(xrgt) * true))))
   ) & (((keys^(x) s= xkss) & (bh^(x) i= hh)) & (((black^(x) * true) & (oldclrr i= 0)) | (((~ black^(x)) * true) & (~ (oldclrr i= 0)))))
    ) ;
post: ( 
	( (rbp^(ret) & (keys^(ret) s= xkss)) &
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (oldclrr i= 0)))) ) &
	( ((~ (fixed i= 0)) & (bh^(ret) i= hh)) |
	((fixed i= 0) & ((oldclrr i= 0) & (bh^(ret) i= (hh - 1)))) )
	) ;
{
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	int xrcolor := xr.color;
	assume (! (xrcolor i== 0));
	loc xrl := xr.left;
	loc x.right := xrl;
	loc xr.left := x;
	int one := 1;
	int zero := 0;
	int x.color := one;
	int xr.color := zero;
	loc p := rbt-delete-left-fixup(x);
	loc xr.left := p;
	int fixed := post-fixed;
	loc ret := xr;
}

bb rbt-delete-left-fixup-case34:
pre: (
    (
     (
        (x |-> loc left: xlft; loc right: xrgt; int key: xky; int color: xclr) * 
	 (
	  (rbp^(xlft) & (keys^(xlft) set-lt xky)) *
	  (rbp^(xrgt) & (xky lt-set keys^(xrgt)))
	 )
     ) & 
     ((((bh^(xlft) + 1) i= bh^(xrgt)) * true) & ((black^(xlft) * true) & ((xclr i= 0) | (black^(xrgt) * true))))
   ) & (((keys^(x) s= xkss) & (bh^(x) i= hh)) & (((black^(x) * true) & (oldclrr i= 0)) | (((~ black^(x)) * true) & (~ (oldclrr i= 0)))))
    ) ;
post: ( 
	( (rbp^(ret) & (keys^(ret) s= xkss)) &
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (oldclrr i= 0)))) ) &
	( ((~ (fixed i= 0)) & (bh^(ret) i= hh)) |
	((fixed i= 0) & ((oldclrr i= 0) & (bh^(ret) i= (hh - 1)))) )
	) ;
{
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	int xrcolor := xr.color;
	assume (xrcolor i== 0);
	loc xrl := xr.left;
	loc xrr := xr.right;
	int xrlcolor := xrl.color;
	int xrrcolor := xrr.color;
	assume (xrrcolor i== 0);
	assume (xrlcolor i== 0);
	int fixed := xcolor;
	int one := 1;
	int zero := 0;
	int xr.color := one;
	int x.color := zero;
	loc ret := x;
}

bb rbt-delete-left-fixup-case5:
pre: (
    (
     (
        (x |-> loc left: xlft; loc right: xrgt; int key: xky; int color: xclr) * 
	 (
	  (rbp^(xlft) & (keys^(xlft) set-lt xky)) *
	  (rbp^(xrgt) & (xky lt-set keys^(xrgt)))
	 )
     ) & 
     ((((bh^(xlft) + 1) i= bh^(xrgt)) * true) & ((black^(xlft) * true) & ((xclr i= 0) | (black^(xrgt) * true))))
   ) & (((keys^(x) s= xkss) & (bh^(x) i= hh)) & (((black^(x) * true) & (oldclrr i= 0)) | (((~ black^(x)) * true) & (~ (oldclrr i= 0)))))
    ) ;
post: ( 
	( (rbp^(ret) & (keys^(ret) s= xkss)) &
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (oldclrr i= 0)))) ) &
	( ((~ (fixed i= 0)) & (bh^(ret) i= hh)) |
	((fixed i= 0) & ((oldclrr i= 0) & (bh^(ret) i= (hh - 1)))) )
	) ;
{
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	int xrcolor := xr.color;
	assume (xrcolor i== 0);
	loc xrl := xr.left;
	loc xrr := xr.right;
	int xrlcolor := xrl.color;
	int xrrcolor := xrr.color;
	assume (xrrcolor i== 0);
	assume (! (xrlcolor i== 0));
	int fixed := 1;
	int zero := 0;
	loc xrll := xrl.left;
	loc xrlr := xrl.right;
	loc xr.left := xrlr;
	loc xrl.right := xr;
	loc xrl.left := x;
	loc x.right := xrll;
	int xrl.color := xcolor;
	int x.color := zero;
	loc ret := xrl;
}

bb rbt-delete-left-fixup-case6:
pre: (
    (
     (
        (x |-> loc left: xlft; loc right: xrgt; int key: xky; int color: xclr) * 
	 (
	  (rbp^(xlft) & (keys^(xlft) set-lt xky)) *
	  (rbp^(xrgt) & (xky lt-set keys^(xrgt)))
	 )
     ) & 
     ((((bh^(xlft) + 1) i= bh^(xrgt)) * true) & ((black^(xlft) * true) & ((xclr i= 0) | (black^(xrgt) * true))))
   ) & (((keys^(x) s= xkss) & (bh^(x) i= hh)) & (((black^(x) * true) & (oldclrr i= 0)) | (((~ black^(x)) * true) & (~ (oldclrr i= 0)))))
    ) ;
post: ( 
	( (rbp^(ret) & (keys^(ret) s= xkss)) &
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (oldclrr i= 0)))) ) &
	( ((~ (fixed i= 0)) & (bh^(ret) i= hh)) |
	((fixed i= 0) & ((oldclrr i= 0) & (bh^(ret) i= (hh - 1)))) )
	) ;
{
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	int xrcolor := xr.color;
	assume (xrcolor i== 0);
	loc xrl := xr.left;
	loc xrr := xr.right;
	int xrlcolor := xrl.color;
	int xrrcolor := xrr.color;
	assume (! (xrrcolor i== 0));
	int fixed := 1;
	int zero := 0;
	loc x.right := xrl;
	loc xr.left := x;
	int xr.color := xcolor;
	int x.color := zero;
	int xrr.color := zero;
	loc ret := xr;
}


