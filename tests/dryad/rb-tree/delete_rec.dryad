define pred rbp^(x): 
  ( ((x l= nil) & emp) |
    (
      (
        (x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * 
        (
	 (
	  (rbp^(lft) & (keys^(lft) set-lt ky)) *
	  (rbp^(rgt) & (ky lt-set keys^(rgt)))
	 ) &
	 (bh^(lft) i= bh^(rgt))
       )
     ) &
     ((clr i= 0) |
      ((black^(lft) * true) & (black^(rgt) * true))
     )  
   )
  ) ;

define pred black^(x):
	( ((x l= nil) & emp) | ((x |-> int color: clr) & (clr i= 0)) ) ;

define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true): 
   	((singleton ky) union (keys^(lft) union keys^(rgt)));
   default: emptyset
  ) ;

define int-fun bh^(x):
  (case (x l= nil): 1;
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(lft) < bh^(rgt)) * true)) & (clr i= 0)): 
   	(bh^(rgt) + 1);
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(lft) < bh^(rgt)) * true)) & (~ (clr i= 0))): 
   	bh^(rgt);
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(rgt) <= bh^(lft)) * true)) & (clr i= 0)): 
   	(bh^(lft) + 1);
   default: bh^(lft)
  ) ;

method rbt-delete(loc x, int kk)
requires: ((((rbp^(x) & (keys^(x) s= xks)) & (bh^(x) i= h)) &
	(kk i-in xks)) & (((black^(x) * true) & (odcr i= 0)) | (((~ black^(x)) * true) & (~ (odcr i= 0)))) ) ;
ensures: (
	((rbp^(ret) & (keys^(ret) s= (xks setminus (singleton kk)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcr i= 0)))) ) &
         (((bh^(ret) i= h) & (~ (pre-fixed i= 0))) | 
	  ((bh^(ret) i= (h - 1)) & ((pre-fixed i= 0) & (odcr i= 0)))) 
	 );

method rbt-find-smallest(loc x)
requires: (((((rbp^(x) & (keys^(x) s= xks3)) & (bh^(x) i= h3)) & (~ (x l= nil))) & (((black^(x) * true) & (oldclr2 i= 0)) | (((~ black^(x)) * true) & (~ (oldclr2 i= 0)))))
       	& ((xks3 s= ((singleton minn) union rest)) & (minn lt-set rest))) ;
ensures: ((((rbp^(x) & (keys^(x) s= xks3)) & (bh^(x) i= h3)) & (((black^(x) * true) & (oldclr2 i= 0)) | (((~ black^(x)) * true) & (~ (oldclr2 i= 0))))) & (ret i= minn)) ;

method rbt-delete-fixup(loc x)
requires: (
    (
     (
        (x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * 
	 (
	  (rbp^(lft) & (keys^(lft) set-lt ky)) *
	  (rbp^(rgt) & (ky lt-set keys^(rgt)))
	 )
     ) & 
     (((((bh^(lft) + 1) i= bh^(rgt)) * true) & ((black^(lft) * true) & ((clr i= 0) | (black^(rgt) * true)))) |
     ((((bh^(rgt) + 1) i= bh^(lft)) * true) & ((black^(rgt) * true) & ((clr i= 0) | (black^(lft) * true)))))
   ) & (((keys^(x) s= xks2) & (bh^(x) i= h2)) & (((black^(x) * true) & (oldclr i= 0)) | (((~ black^(x)) * true) & (~ (oldclr i= 0)))))
    ) ;
ensures: ( 
	( (rbp^(ret) & (keys^(ret) s= xks2)) &
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (oldclr i= 0)))) ) &
	( ((~ (post-fixed i= 0)) & (bh^(ret) i= h2)) |
	((post-fixed i= 0) & ((oldclr i= 0) & (bh^(ret) i= (h2 - 1)))) )
	) ;


bb rbt-delete-nil:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (x l== nil);
	int fixed := 1;
	loc ret := nil;
}

bb rbt-delete-current-left-nil-right-nil:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (xkey i== k);
	assume (xl l== nil);
	assume (xr l== nil);
	int xcolor := x.color;
	free x;
	int fixed := xcolor;
	loc ret := nil;
}

bb rbt-delete-current-left-nil-right-red:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (xkey i== k);
	assume (xl l== nil);
	assume (! (xr l== nil));
	int xrcolor := xr.color;
	assume (! (xrcolor i== 0));
	int zero := 0;
	int xr.color := zero;
	free x;
	int fixed := 1;
	loc ret := xr;
}

bb rbt-delete-current-left-nil-right-black:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (xkey i== k);
	assume (xl l== nil);
	assume (! (xr l== nil));
	int xrcolor := xr.color;
	assume (xrcolor i== 0);
	int xcolor := x.color;
	free x;
	int fixed := xcolor;
	loc ret := xr;
}

bb rbt-delete-current-right-nil-left-red:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (xkey i== k);
	assume (! (xl l== nil));
	assume (xr l== nil);
	int xlcolor := xl.color;
	assume (! (xlcolor i== 0));
	int zero := 0;
	int xl.color := zero;
	free x;
	int fixed := 1;
	loc ret := xl;
}

bb rbt-delete-current-right-nil-left-black:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (xkey i== k);
	assume (! (xl l== nil));
	assume (xr l== nil);
	int xlcolor := xl.color;
	assume (xlcolor i== 0);
	int xcolor := x.color;
	free x;
	int fixed := xcolor;
	loc ret := xl;
}

bb rbt-delete-current-find-pre:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: ((rbp^(xr) & (~ (xr l= nil))) * true) ;
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (xkey i== k);
	assume (! (xl l== nil));
	assume (! (xr l== nil));
}

bb rbt-delete-current-replace-pre:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: ((rbp^(xr) & (min i-in keys^(xr))) * true) ;
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (xkey i== k);
	assume (! (xl l== nil));
	assume (! (xr l== nil));
	int min := rbt-find-smallest(xr);
}

bb rbt-delete-current-replace-fixed:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (xkey i== k);
	assume (! (xl l== nil));
	assume (! (xr l== nil));
	int min := rbt-find-smallest(xr);
	int x.key := min;
	loc n := rbt-delete(xr; min);
	loc x.right := n;
	assume (! (pre-fixed i== 0));
	int fixed := pre-fixed;
	loc ret := x;
}

bb rbt-delete-current-replace-unfixed-pre:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
     (
        (x |-> loc left: xl; loc right: n; int key: min; int color: xcolor) * 
	 (
	  (rbp^(xl) & (keys^(xl) set-lt min)) *
	  (rbp^(n) & (min lt-set keys^(n)))
	 )
     ) & 
     (((((bh^(xl) + 1) i= bh^(n)) * true) & ((black^(xl) * true) & ((xcolor i= 0) | (black^(n) * true)))) |
     ((((bh^(n) + 1) i= bh^(xl)) * true) & ((black^(n) * true) & ((xcolor i= 0) | (black^(xl) * true)))))
   ) ;
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (xkey i== k);
	assume (! (xl l== nil));
	assume (! (xr l== nil));
	int min := rbt-find-smallest(xr);
	int x.key := min;
	loc n := rbt-delete(xr; min);
	loc x.right := n;
	assume (pre-fixed i== 0);
}

bb rbt-delete-current-replace-unfixed:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (xkey i== k);
	assume (! (xl l== nil));
	assume (! (xr l== nil));
	int min := rbt-find-smallest(xr);
	int x.key := min;
	loc n := rbt-delete(xr; min);
	loc x.right := n;
	assume (pre-fixed i== 0);
	loc ret := rbt-delete-fixup(x);
	int fixed := post-fixed;
}

bb rbt-delete-left-pre:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: ((rbp^(xl) & (k i-in keys^(xl))) * true) ;
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (! (xkey i== k));
	assume (k < xkey);
}

bb rbt-delete-right-pre:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: ((rbp^(xr) & (k i-in keys^(xr))) * true) ;
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (! (xkey i== k));
	assume (! (k < xkey));
}

bb rbt-delete-left-fixed:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (! (xkey i== k));
	assume (k < xkey);
	loc n := rbt-delete(xl; k);
	loc x.left := n;
	assume (! (pre-fixed i== 0));
	int fixed := pre-fixed;
	loc ret := x;
}

bb rbt-delete-right-fixed:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (! (xkey i== k));
	assume (! (k < xkey));
	loc n := rbt-delete(xr; k);
	loc x.right := n;
	assume (! (pre-fixed i== 0));
	int fixed := pre-fixed;
	loc ret := x;
}

bb rbt-delete-left-unfixed-pre:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
     (
        (x |-> loc left: n; loc right: xr; int key: xkey; int color: xcolor) * 
	 (
	  (rbp^(n) & (keys^(n) set-lt xkey)) *
	  (rbp^(xr) & (xkey lt-set keys^(xr)))
	 )
     ) & 
     (((((bh^(n) + 1) i= bh^(xr)) * true) & ((black^(n) * true) & ((xcolor i= 0) | (black^(xr) * true)))) |
     ((((bh^(xr) + 1) i= bh^(n)) * true) & ((black^(xr) * true) & ((xcolor i= 0) | (black^(n) * true)))))
   ) ;
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (! (xkey i== k));
	assume (k < xkey);
	loc n := rbt-delete(xl; k);
	loc x.left := n;
	assume (pre-fixed i== 0);
}

bb rbt-delete-right-unfixed-pre:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
     (
        (x |-> loc left: xl; loc right: n; int key: xkey; int color: xcolor) * 
	 (
	  (rbp^(xl) & (keys^(xl) set-lt xkey)) *
	  (rbp^(n) & (xkey lt-set keys^(n)))
	 )
     ) & 
     (((((bh^(xl) + 1) i= bh^(n)) * true) & ((black^(xl) * true) & ((xcolor i= 0) | (black^(n) * true)))) |
     ((((bh^(n) + 1) i= bh^(xl)) * true) & ((black^(n) * true) & ((xcolor i= 0) | (black^(xl) * true)))))
   ) ;
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (! (xkey i== k));
	assume (! (k < xkey));
	loc n := rbt-delete(xr; k);
	loc x.right := n;
	assume (pre-fixed i== 0);
}

bb rbt-delete-left-unfixed:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (! (xkey i== k));
	assume (k < xkey);
	loc n := rbt-delete(xl; k);
	loc x.left := n;
	assume (pre-fixed i== 0);
	loc ret := rbt-delete-fixup(x);
	int fixed := post-fixed;
}

bb rbt-delete-right-unfixed:
pre: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) &
	(k i-in xkss)) & (((black^(x) * true) & (odcrr i= 0)) | (((~ black^(x)) * true) & (~ (odcrr i= 0)))) ) ;
post: (
	((rbp^(ret) & (keys^(ret) s= (xkss setminus (singleton k)))) & 
	((black^(ret) * true) | (((~ black^(ret)) * true) & (~ (odcrr i= 0)))) ) &
         (((bh^(ret) i= hh) & (~ (fixed i= 0))) | 
	  ((bh^(ret) i= (hh - 1)) & ((fixed i= 0) & (odcrr i= 0)))) 
	 );
{
	assume (! (x l== nil));
	loc xl := x.left;
	loc xr := x.right;
	int xkey := x.key;
	int xcolor := x.color;
	assume (! (xkey i== k));
	assume (! (k < xkey));
	loc n := rbt-delete(xr; k);
	loc x.right := n;
	assume (pre-fixed i== 0);
	loc ret := rbt-delete-fixup(x);
	int fixed := post-fixed;
}


