define pred rbp^(x): 
  ( ((x l= nil) & emp) |
    (
      (
        (x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * 
        (
	 (
	  (rbp^(lft) & (keys^(lft) set-lt ky)) *
	  (rbp^(rgt) & (ky lt-set keys^(rgt)))
	 ) &
	 (bh^(lft) i= bh^(rgt))
       )
     ) &
     ((clr i= 0) |
      ((black^(lft) * true) & (black^(rgt) * true))
     )  
   )
  ) ;

define pred black^(x):
	( ((x l= nil) & emp) | ((x |-> int color: clr) & (clr i= 0)) ) ;

define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true): 
   	((singleton ky) union (keys^(lft) union keys^(rgt)));
   default: emptyset
  ) ;

define int-fun bh^(x):
  (case (x l= nil): 1;
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(lft) < bh^(rgt)) * true)) & (clr i= 0)): 
   	(bh^(rgt) + 1);
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(lft) < bh^(rgt)) * true)) & (~ (clr i= 0))): 
   	bh^(rgt);
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(rgt) <= bh^(lft)) * true)) & (clr i= 0)): 
   	(bh^(lft) + 1);
   default: bh^(lft)
  ) ;

method rbt-find-smallest(loc x)
requires: (((((rbp^(x) & (keys^(x) s= xks3)) & (bh^(x) i= h3)) & (~ (x l= nil))) & (((black^(x) * true) & (oldclr2 i= 0)) | (((~ black^(x)) * true) & (~ (oldclr2 i= 0)))))
       	& ((xks3 s= ((singleton minn) union rest)) & (minn lt-set rest))) ;
ensures: ((((rbp^(x) & (keys^(x) s= xks3)) & (bh^(x) i= h3)) & (((black^(x) * true) & (oldclr2 i= 0)) | (((~ black^(x)) * true) & (~ (oldclr2 i= 0))))) & (ret i= minn)) ;

bb rbt-find-smallest-base:
pre: (((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) & (~ (x l= nil))) & (((black^(x) * true) & (oldclrr i= 0)) | (((~ black^(x)) * true) & (~ (oldclrr i= 0)))))
       	& ((xkss s= ((singleton minn) union restt)) & (minn lt-set restt))) ;
post: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) & (((black^(x) * true) & (oldclrr i= 0)) | (((~ black^(x)) * true) & (~ (oldclrr i= 0))))) & (ret i= minn)) ;
{
	loc xl := x.left;
	int xk := x.key;
	assume (xl l== nil);
	int ret := xk;
}

bb rbt-find-smallest-recursive-pre:
pre: (((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) & (~ (x l= nil))) & (((black^(x) * true) & (oldclrr i= 0)) | (((~ black^(x)) * true) & (~ (oldclrr i= 0)))))
       	& ((xkss s= ((singleton minn) union restt)) & (minn lt-set restt))) ;
post: ((rbp^(xl) & (~ (xl l= nil))) * true) ;
{
	loc xl := x.left;
	int xk := x.key;
	assume (! (xl l== nil));
}

bb avl-find-smallest-recursive:
pre: (((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) & (~ (x l= nil))) & (((black^(x) * true) & (oldclrr i= 0)) | (((~ black^(x)) * true) & (~ (oldclrr i= 0)))))
       	& ((xkss s= ((singleton minn) union restt)) & (minn lt-set restt))) ;
post: ((((rbp^(x) & (keys^(x) s= xkss)) & (bh^(x) i= hh)) & (((black^(x) * true) & (oldclrr i= 0)) | (((~ black^(x)) * true) & (~ (oldclrr i= 0))))) & (ret i= minn)) ;
{
	loc xl := x.left;
	int xk := x.key;
	assume (! (xl l== nil));
	int ret := rbt-find-smallest(xl);
}
