define pred rbp^(x): 
  ( ((x l= nil) & emp) |
    (
      (
        (x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * 
        (
	 (
	  (rbp^(lft) & (keys^(lft) set-lt ky)) *
	  (rbp^(rgt) & (ky lt-set keys^(rgt)))
	 ) &
	 (bh^(lft) i= bh^(rgt))
       )
     ) &
     ((clr i= 0) |
      ((black^(lft) * true) & (black^(rgt) * true))
     )  
   )
  ) ;

define pred black^(x):
	( ((x l= nil) & emp) | ((x |-> int color: clr) & (clr i= 0)) ) ;

define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true): 
   	((singleton ky) union (keys^(lft) union keys^(rgt)));
   default: emptyset
  ) ;

define int-fun bh^(x):
  (case (x l= nil): 1;
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(lft) < bh^(rgt)) * true)) & (clr i= 0)): 
   	(bh^(rgt) + 1);
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(lft) < bh^(rgt)) * true)) & (~ (clr i= 0))): 
   	bh^(rgt);
   case ((((x |-> loc left: lft; loc right: rgt; int key: ky; int color: clr) * true) &
	((bh^(rgt) <= bh^(lft)) * true)) & (clr i= 0)): 
   	(bh^(lft) + 1);
   default: bh^(lft)
  ) ;

method rbt-insert-left-fixup(loc x)
requires: (
    (
     (
        (x |-> loc left: llft; loc right: rrgt; int key: kky; int color: cclr) * 
	 (
	  (((llft |-> loc left: lftlft; loc right: lftrgt; int key: lftky; int color: lftclr) * 
	   ( (rbp^(lftlft) & (keys^(lftlft) set-lt lftky)) *
	    (rbp^(lftrgt) & (lftky lt-set keys^(lftrgt))) )) &
	   (keys^(llft) set-lt kky)) *
	  (rbp^(rrgt) & (kky lt-set keys^(rrgt)))
	 )
     ) & 
     ( (((bh^(lftlft) i= bh^(lftrgt)) * true) & ((bh^(lftrgt) i= bh^(rrgt)) * true)) & 
       ((~ (lftclr i= 0)) & (((cclr i= 0) & ((black^(lftlft) * true) | (black^(lftrgt) * true))) | ((black^(rrgt) * (black^(lftlft) * black^(lftrgt))) * true))) )
   )
   & (((keys^(x) s= xks2) & (bh^(x) i= h2)) & (((black^(x) * true) & (oldclr2 i= 0)) | (((~ black^(x)) * true) & (~ (oldclr2 i= 0)))))
   ) ;
ensures: (
    (
     (
        (ret |-> loc left: retlft; loc right: retrgt; int key: retky; int color: retclr) * 
        (
	 (
	  (rbp^(retlft) & (keys^(retlft) set-lt retky)) *
	  (rbp^(retrgt) & (retky lt-set keys^(retrgt)))
	 ) &
	 (bh^(retlft) i= bh^(retrgt))
       )
     ) & 
     ((keys^(ret) s= xks2) & (bh^(ret) i= h2))
    ) &
    ((retclr i= 0) | (((black^(retlft) * true) | (black^(retrgt) * true)) & ((~ (oldclr2 i= 0)) | ((black^(retlft) * true) & (black^(retrgt) * true)))))
  ) ;


bb rbt-insert-left-fixup-case3:
pre: (
    (
     (
        (x |-> loc left: llft; loc right: rrgt; int key: kky; int color: cclr) * 
	 (
	  (((llft |-> loc left: lftlft; loc right: lftrgt; int key: lftky; int color: lftclr) * 
	   ( (rbp^(lftlft) & (keys^(lftlft) set-lt lftky)) *
	    (rbp^(lftrgt) & (lftky lt-set keys^(lftrgt))) )) &
	   (keys^(llft) set-lt kky)) *
	  (rbp^(rrgt) & (kky lt-set keys^(rrgt)))
	 )
     ) & 
     ( (((bh^(lftlft) i= bh^(lftrgt)) * true) & ((bh^(lftrgt) i= bh^(rrgt)) * true)) & 
       ((~ (lftclr i= 0)) & (((cclr i= 0) & ((black^(lftlft) * true) | (black^(lftrgt) * true))) | ((black^(rrgt) * (black^(lftlft) * black^(lftrgt))) * true))) )
   )
   & (((keys^(x) s= xks2) & (bh^(x) i= h2)) & (((black^(x) * true) & (oldclr2 i= 0)) | (((~ black^(x)) * true) & (~ (oldclr2 i= 0)))))
   ) ;
post: (
    (
     (
        (ret |-> loc left: xl; loc right: xr; int key: xk; int color: one) * 
        (
	 (
	  (rbp^(xl) & (keys^(xl) set-lt xk)) *
	  (rbp^(xr) & (xk lt-set keys^(xr)))
	 ) &
	 (bh^(xl) i= bh^(xr))
       )
     ) & 
     ((keys^(ret) s= xks2) & (bh^(ret) i= h2))
    ) &
    ((one i= 0) | (((black^(xl) * true) | (black^(xr) * true)) & ((~ (oldclr2 i= 0)) | ((black^(xl) * true) & (black^(xr) * true)))))
  ) ;
{
	int xk := x.key;
	int xc := x.color;
	loc xl := x.left;
	loc xr := x.right;
	int xrcolor := xr.color;
	assume (! ((xr l== nil) || (xrcolor i== 0)));
	int zero := 0;
	int one := 1;
	int xl.color := zero;
	int xr.color := zero;
	int x.color := one;
	loc ret := x;
}

bb rbt-insert-left-fixup-else:
pre: (
    (
     (
        (x |-> loc left: llft; loc right: rrgt; int key: kky; int color: cclr) * 
	 (
	  (((llft |-> loc left: lftlft; loc right: lftrgt; int key: lftky; int color: lftclr) * 
	   ( (rbp^(lftlft) & (keys^(lftlft) set-lt lftky)) *
	    (rbp^(lftrgt) & (lftky lt-set keys^(lftrgt))) )) &
	   (keys^(llft) set-lt kky)) *
	  (rbp^(rrgt) & (kky lt-set keys^(rrgt)))
	 )
     ) & 
     ( (((bh^(lftlft) i= bh^(lftrgt)) * true) & ((bh^(lftrgt) i= bh^(rrgt)) * true)) & 
       ((~ (lftclr i= 0)) & (((cclr i= 0) & ((black^(lftlft) * true) | (black^(lftrgt) * true))) | ((black^(rrgt) * (black^(lftlft) * black^(lftrgt))) * true))) )
   )
   & (((keys^(x) s= xks2) & (bh^(x) i= h2)) & (((black^(x) * true) & (oldclr2 i= 0)) | (((~ black^(x)) * true) & (~ (oldclr2 i= 0)))))
   ) ;
post: (
    (
     (
        (ret |-> loc left: xl; loc right: xr; int key: xk; int color: xc) * 
        (
	 (
	  (rbp^(xl) & (keys^(xl) set-lt xk)) *
	  (rbp^(xr) & (xk lt-set keys^(xr)))
	 ) &
	 (bh^(xl) i= bh^(xr))
       )
     ) & 
     ((keys^(ret) s= xks2) & (bh^(ret) i= h2))
    ) &
    ((xc i= 0) | (((black^(xl) * true) | (black^(xr) * true)) & ((~ (oldclr2 i= 0)) | ((black^(xl) * true) & (black^(xr) * true)))))
  ) ;
{
	int xk := x.key;
	int xc := x.color;
	loc xl := x.left;
	loc xr := x.right;
	int xrcolor := xr.color;
	assume ((xr l== nil) || (xrcolor i== 0));
	loc pl := xl.left;
	loc pr := xl.right;
	int plcolor := pl.color;
	int prcolor := pr.color;
	assume ((pr l== nil) || (prcolor i== 0));
	assume ((pl l== nil) || (plcolor i== 0));
	loc ret := x;
}

bb rbt-insert-left-fixup-case4:
pre: (
    (
     (
        (x |-> loc left: llft; loc right: rrgt; int key: kky; int color: cclr) * 
	 (
	  (((llft |-> loc left: lftlft; loc right: lftrgt; int key: lftky; int color: lftclr) * 
	   ( (rbp^(lftlft) & (keys^(lftlft) set-lt lftky)) *
	    (rbp^(lftrgt) & (lftky lt-set keys^(lftrgt))) )) &
	   (keys^(llft) set-lt kky)) *
	  (rbp^(rrgt) & (kky lt-set keys^(rrgt)))
	 )
     ) & 
     ( (((bh^(lftlft) i= bh^(lftrgt)) * true) & ((bh^(lftrgt) i= bh^(rrgt)) * true)) & 
       ((~ (lftclr i= 0)) & (((cclr i= 0) & ((black^(lftlft) * true) | (black^(lftrgt) * true))) | ((black^(rrgt) * (black^(lftlft) * black^(lftrgt))) * true))) )
   )
   & (((keys^(x) s= xks2) & (bh^(x) i= h2)) & (((black^(x) * true) & (oldclr2 i= 0)) | (((~ black^(x)) * true) & (~ (oldclr2 i= 0)))))
   ) ;
post: (
    (
     (
        (ret |-> loc left: xl; loc right: x; int key: prkey; int color: zero) * 
        (
	 (
	  (rbp^(xl) & (keys^(xl) set-lt prkey)) *
	  (rbp^(x) & (prkey lt-set keys^(x)))
	 ) &
	 (bh^(xl) i= bh^(x))
       )
     ) & 
     ((keys^(ret) s= xks2) & (bh^(ret) i= h2))
    ) &
    ((zero i= 0) | (((black^(xl) * true) | (black^(x) * true)) & ((~ (oldclr2 i= 0)) | ((black^(xl) * true) & (black^(x) * true)))))
  ) ;
{
	int xk := x.key;
	int xc := x.color;
	loc xl := x.left;
	loc xr := x.right;
	int xrcolor := xr.color;
	assume ((xr l== nil) || (xrcolor i== 0));
	loc pl := xl.left;
	loc pr := xl.right;
	int plcolor := pl.color;
	int prcolor := pr.color;
	int prkey := pr.key;
	assume (! ((pr l== nil) || (prcolor i== 0)));
	loc prl := pr.left;
	loc prr := pr.right;
	loc xl.right := prl;
	loc x.left := prr;
	loc pr.left := xl;
	loc pr.right := x;
	int zero := 0;
	int one := 1;
	int pr.color := zero;
	int x.color := one;
	loc ret := pr;
}

bb rbt-insert-left-fixup-case5:
pre: (
    (
     (
        (x |-> loc left: llft; loc right: rrgt; int key: kky; int color: cclr) * 
	 (
	  (((llft |-> loc left: lftlft; loc right: lftrgt; int key: lftky; int color: lftclr) * 
	   ( (rbp^(lftlft) & (keys^(lftlft) set-lt lftky)) *
	    (rbp^(lftrgt) & (lftky lt-set keys^(lftrgt))) )) &
	   (keys^(llft) set-lt kky)) *
	  (rbp^(rrgt) & (kky lt-set keys^(rrgt)))
	 )
     ) & 
     ( (((bh^(lftlft) i= bh^(lftrgt)) * true) & ((bh^(lftrgt) i= bh^(rrgt)) * true)) & 
       ((~ (lftclr i= 0)) & (((cclr i= 0) & ((black^(lftlft) * true) | (black^(lftrgt) * true))) | ((black^(rrgt) * (black^(lftlft) * black^(lftrgt))) * true))) )
   )
   & (((keys^(x) s= xks2) & (bh^(x) i= h2)) & (((black^(x) * true) & (oldclr2 i= 0)) | (((~ black^(x)) * true) & (~ (oldclr2 i= 0)))))
   ) ;
post: (
    (
     (
        (ret |-> loc left: pl; loc right: x; int key: pkey; int color: zero) * 
        (
	 (
	  (rbp^(pl) & (keys^(pl) set-lt pkey)) *
	  (rbp^(x) & (pkey lt-set keys^(x)))
	 ) &
	 (bh^(pl) i= bh^(x))
       )
     ) & 
     ((keys^(ret) s= xks2) & (bh^(ret) i= h2))
    ) &
    ((zero i= 0) | (((black^(pl) * true) | (black^(x) * true)) & ((~ (oldclr2 i= 0)) | ((black^(pl) * true) & (black^(x) * true)))))
  ) ;
{
	int xk := x.key;
	int xc := x.color;
	loc xl := x.left;
	loc xr := x.right;
	int xrcolor := xr.color;
	assume ((xr l== nil) || (xrcolor i== 0));
	loc pl := xl.left;
	loc pr := xl.right;
	int pkey := xl.key;
	int plcolor := pl.color;
	int prcolor := pr.color;	
	assume ((pr l== nil) || (prcolor i== 0));
	assume (! ((pl l== nil) || (plcolor i== 0)));
	loc xl.right := x;
	loc x.left := pr;
	int zero := 0;
	int one := 1;
	int xl.color := zero;
	int x.color := one;
	loc ret := xl;
}


