define pred sll^(x): 
  ( 
	((x l= nil) & emp) | 
          ((x |-> loc next: nxt; int key: ky) * sll^(nxt))  
  )
  axiom: (lseg^(x, x) * (((x l= nil) & (keys^(x) s= emptyset)) | ((~ (x l= nil)) & (~ (keys^(x) s= emptyset)))));

define pred sorted-sll^(x): 
  ( 
	((x l= nil) & emp) | 
          ((x |-> loc next: nxt; int key: ky) * 
			(sorted-sll^(nxt) & (ky le-set keys^(nxt)))
		  )  
  )
  axiom: (sorted-lseg^(x, x) * sll^(x));
  
define set-fun keys^(x):
  (case (x l= nil): emptyset;
   case ((x |-> loc next: nxt; int key: ky) * true): 
   	((singleton ky) union keys^(nxt));
   default: emptyset
  ) ;

define relation lseg^(head, tail): 
  ( 
	((head l= tail) & emp) | 
          ((head |-> loc next: nxt; int key: ky) * (lseg^(nxt, tail) & (ky le-set lseg-keys^(nxt, tail))))  
  ) 
  axiom: ( (((head l= tail) => (emp & (lseg-keys^(head, tail) s= emptyset))) & ((tail l= nil) => (sll^(head) & (keys^(head) s= lseg-keys^(head, tail))))) &
	( (sll^(tail) -* (sll^(head) & (keys^(head) s= (lseg-keys^(head, tail) union keys^(tail))))) &
	  (((tail |-> loc next: virtual tn; int key: virtual tk) * sll^(tn)) -* ((lseg^(head, tn) & (lseg-keys^(head, tn) s= (lseg-keys^(head, tail) union (singleton tk)))) * sll^(tn))) ) ) ;

define relation sorted-lseg^(head, tail): 
  ( 
	((head l= tail) & emp) | 
          ((head |-> loc next: nxt; int key: ky) * (sorted-lseg^(nxt, tail) & (ky le-set lseg-keys^(nxt, tail))))  
  ) 
  axiom: ( lseg^(head, tail) &
	  ( ((tail l= nil) => sorted-sll^(head)) &
	( (sorted-sll^(tail) -* ((lseg-keys^(head, tail) le keys^(tail)) => sorted-sll^(head))) &
	  (((tail |-> loc next: virtual tn; int key: virtual tk) * sll^(tn)) -* (((lseg-keys^(head, tail) set-le tk) * true) => (sorted-lseg^(head, tn) * sll^(tn)))) ) ) ) ;

define bin-set-fun lseg-keys^(head, tail):
  (case (head l= tail) : emptyset;
   case ((head |-> loc next: nxt; int key: ky) * true): 
   	((singleton ky) union lseg-keys^(nxt, tail));
   default: emptyset
  ) ;


bb find-last-before-loop:
pre: ((sorted-sll^(y) * (keys^(y) s= yks)) & (~ (y l= nil)));
post: ( (((sorted-lseg^(y, curr) & (lseg-keys^(y, curr) set-le currd)) * (curr |-> loc next: currn; int key: currd)) *
	(sorted-sll^(currn) & (currd le-set keys^(currn)))) & (((lseg-keys^(y, curr) union (singleton currd)) union keys^(currn)) s= yks) ) ; 
{
	loc curr := y;
	loc currn := curr.next;
	int currd := curr.key;
}

bb find-last-in-loop:
pre: ( (((sorted-lseg^(y, curr) & (lseg-keys^(y, curr) set-le currd)) * (curr |-> loc next: currn; int key: currd)) *
	(sorted-sll^(currn) & (currd le-set keys^(currn)))) & (((lseg-keys^(y, curr) union (singleton currd)) union keys^(currn)) s= yks) ) ; 
post: ( (((sorted-lseg^(y, curr1) & (lseg-keys^(y, curr1) set-le currd1)) * (curr1 |-> loc next: currn1; int key: currd1)) *
	(sorted-sll^(currn1) & (currd1 le-set keys^(currn1)))) & (((lseg-keys^(y, curr1) union (singleton currd1)) union keys^(currn1)) s= yks) ) ; 
{
	assume (! (currn l== nil));
	loc curr1 := currn;
	loc currn1 := currn.next;
	int currd1 := currn.key;
}

bb find-last-after-loop:
pre: ( (((sorted-lseg^(y, curr) & (lseg-keys^(y, curr) set-le currd)) * (curr |-> loc next: currn; int key: currd)) *
	(sorted-sll^(currn) & (currd le-set keys^(currn)))) & (((lseg-keys^(y, curr) union (singleton currd)) union keys^(currn)) s= yks) ) ; 
post: ((sorted-lseg^(y, ret) & ((lseg-keys^(y, ret) set-le lastd) & ((lseg-keys^(y, ret) union (singleton lastd)) s= ykss)))
       	* (ret |-> loc next: nill; int key: lastd)) ; 
{
	assume (currn l== nil);
	loc ret := curr;
}

