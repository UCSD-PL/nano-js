define pred sorted-list^(x): 
  ( 
	((x l= nil) & emp) | 
          (((x |-> loc next: nxt; int value: ky; loc left: lft; loc right: rgt; loc tree: st) * 
			(sorted-list^(nxt) & (ky le-set keys-list^(nxt)))
		  )  & (((lft l= nil) & (rgt l= nil)) & (st l= nil)))
  ) ;
  
define set-fun keys-list^(x):
  (case (x l= nil): emptyset;
  case ((x |-> loc next: nxt; int value: ky; loc left: lft; loc right: rgt; loc tree: st) * true): 
   	((singleton ky) union keys-list^(nxt));
   default: emptyset
  ) ;


define pred sorted-stack^(x): 
  ( 
	((x l= nil) & emp) | 
          (((x |-> loc next: nxt; loc tree: st; loc left: lft; loc right: rgt) * ((sorted-stack^(nxt) * (bst^(st) & (~ (st l= nil)))) & (keys-stack^(nxt) le keys-bst^(st)))) & ((lft l= nil) & (rgt l= nil)))
  );

define set-fun keys-stack^(x):
  (case (x l= nil): emptyset;
  case ((x |-> loc next: nxt; loc tree: st; loc left: lft; loc right: rgt) * true): 
   	(keys-bst^(st) union keys-stack^(nxt));
   default: emptyset
  ) ;


define pred bst^(x): 
  ( ((x l= nil) & emp) |
	  (((x |-> loc left: lft; loc right: rgt; int key: ky; loc next: nxt; loc tree: st) * ((bst^(lft) & (keys-bst^(lft) set-le ky)) * (bst^(rgt) & (ky le-set keys-bst^(rgt))))) & ((nxt l= nil) & (st l= nil)))
  );

define set-fun keys-bst^(x):
  (case (x l= nil): emptyset;
  case ((x |-> loc left: lft; loc right: rgt; int key: ky; loc next: nxt; loc tree: st) * true): 
   	((singleton ky) union (keys-bst^(lft) union keys-bst^(rgt)));
   default: emptyset
  ) ;

	   

bb tree-to-list-nil:
pre: (bst^(t) & (k s= keys-bst^(t)));
post: (sorted-list^(ret) & (k s= keys-list^(ret)));
{
	assume (t l== nil);
	loc ret := nil;
}

bb tree-to-list-loop-pre:
pre: (bst^(t) & (k s= keys-bst^(t)));
post: (((sorted-stack^(s) * sorted-list^(l)) & (k s= (keys-list^(l) union keys-stack^(s)))) & (keys-stack^(s) le keys-list^(l)));
{
	assume (! (t l== nil));
	loc l := nil;
	malloc s;
	loc s.tree := t;
	loc nill := nil;
	loc s.next := nill;
}

bb tree-to-list-loop-inductive-left-nil-right-nil:
pre: (((sorted-stack^(s) * sorted-list^(l)) & (kk s= (keys-list^(l) union keys-stack^(s)))) & (keys-stack^(s) le keys-list^(l)));
post: (((sorted-stack^(s1) * sorted-list^(l1)) & (kk s= (keys-list^(l1) union keys-stack^(s1)))) & (keys-stack^(s1) le keys-list^(l1)));
{
	assume (! (s l== nil));
	loc tn := s.tree;
	loc s1 := s.next;
	free s;
	loc tnleft := tn.left;
	assume (tnleft l== nil);
	loc tnright := tn.right;
	assume (tnright l== nil);
	malloc ln;
	int tnkey := tn.key;
	int ln.value := tnkey;
	loc ln.next := l;
	loc l1 := ln;
	free tn;
}

bb tree-to-list-loop-inductive-left-nil-right-non-nil:
pre: (((sorted-stack^(s) * sorted-list^(l)) & (k s= (keys-list^(l) union keys-stack^(s)))) & (keys-stack^(s) le keys-list^(l)));
post: (((sorted-stack^(s2) * sorted-list^(l)) & (k s= (keys-list^(l) union keys-stack^(s2)))) & (keys-stack^(s2) le keys-list^(l)));
{
	assume (! (s l== nil));
	loc tn := s.tree;
	loc s1 := s.next;
	free s;
	loc tnleft := tn.left;
	assume (tnleft l== nil);
	loc tnright := tn.right;
	assume (! (tnright l== nil));

	loc nill := nil;
	loc tn.right := nill;
	loc tn.left := nill;

	malloc sn1;
	loc sn1.tree := tn;
	loc sn1.next := s1;
	malloc sn2;
	loc sn2.tree := tnright;
	loc sn2.next := sn1;

	loc s2 := sn2;
}

bb tree-to-list-loop-inductive-left-non-nil-right-nil:
pre: (((sorted-stack^(s) * sorted-list^(l)) & (k s= (keys-list^(l) union keys-stack^(s)))) & (keys-stack^(s) le keys-list^(l)));
post: (((sorted-stack^(s2) * sorted-list^(l1)) & (k s= (keys-list^(l1) union keys-stack^(s2)))) & (keys-stack^(s2) le keys-list^(l1)));
{
	assume (! (s l== nil));
	loc tn := s.tree;
	loc s1 := s.next;
	free s;
	loc tnleft := tn.left;
	assume (! (tnleft l== nil));

	malloc sn;
	loc sn.tree := tnleft;
	loc sn.next := s1;
	loc s2 := sn;

	loc tnright := tn.right;
	assume (tnright l== nil);
	malloc ln;
	int tnkey := tn.key;
	int ln.value := tnkey;
	loc ln.next := l;
	loc l1 := ln;
	free tn;
}


bb tree-to-list-loop-inductive-left-non-nil-right-non-nil:
pre: (((sorted-stack^(s) * sorted-list^(l)) & (k s= (keys-list^(l) union keys-stack^(s)))) & (keys-stack^(s) le keys-list^(l)));
post: (((sorted-stack^(s3) * sorted-list^(l)) & (k s= (keys-list^(l) union keys-stack^(s3)))) & (keys-stack^(s3) le keys-list^(l)));
{
	assume (! (s l== nil));
	loc tn := s.tree;
	loc s1 := s.next;
	free s;
	loc tnleft := tn.left;
	assume (! (tnleft l== nil));

	malloc sn;
	loc sn.tree := tnleft;
	loc sn.next := s1;
	loc s2 := sn;

	loc tnright := tn.right;
	assume (! (tnright l== nil));

	loc nill := nil;
	loc tn.right := nill;
	loc tn.left := nill;

	malloc sn1;
	loc sn1.tree := tn;
	loc sn1.next := s2;
	malloc sn2;
	loc sn2.tree := tnright;
	loc sn2.next := sn1;

	loc s3 := sn2;
}

bb tree-to-list-loop-post:
pre: (((sorted-stack^(s) * sorted-list^(l)) & (k s= (keys-list^(l) union keys-stack^(s)))) & (keys-stack^(s) le keys-list^(l)));
post: (sorted-list^(ret) & (k s= keys-list^(ret)));
{
	assume (s l== nil);
	loc ret := l;
}