define pred tree^(x):
	( ((x l= nil) & emp)
	| ((x |-> loc left: lft; loc right: rgt; int key: ky) * (tree^(lft) * tree^(rgt)))  
	);

define pred pretree^(x):
	( ((x l= nil) & emp)
	| (((x |-> loc left: lft; loc right: rgt; int key: ky) * (pretree^(lft) * pretree^(rgt)))
		& ((((order^(lft) i= (ky + 1)) * true) | (lft l= nil))
		& (((order^(rgt) i= ((ky + 1) + size^(lft))) * true) | (rgt l= nil))))  
	);

define int-fun order^(x):
	( case (x l= nil): 0;
	  case ((x |-> loc left: lft; loc right: rgt; int key: ky) * true): 
		ky;
	  default: 0
	);

define int-fun size^(x):
	( case (x l= nil): 0;
	  case ((x |-> loc left: lft; loc right: rgt; int key: ky) * true): 
		(1 + (size^(lft) + size^(rgt)));
	  default: 0
	);


method preorder(loc x, int n)
requires: (tree^(x) & (szarg i= size^(x)));
ensures: (pretree^(x) & ((ret i= (n + szarg)) & (((order^(x) i= n) | (x l= nil)) & (size^(x) i= szarg))));


bb preorder-basic:
pre: (tree^(x) & (sz i= size^(x)));
post: (pretree^(x) & ((ret i= (n + sz)) & (((order^(x) i= n) | (x l= nil)) & (size^(x) i= sz))));
{
	assume (x l== nil);
	int ret := n;
}

bb preorder-inductive:
pre: (tree^(x) & (sz i= size^(x)));
post: (pretree^(x) & ((ret i= (n + sz)) & (((order^(x) i= n) | (x l= nil)) & (size^(x) i= sz))));
{
	assume (! (x l== nil));
	int x.key := n;
	int n1 := n + 1;
	loc xl := x.left;
	int n2 := preorder(xl; n1);
	loc xr := x.right;
	int n3 := preorder(xr; n2);
	int ret := n3;
}

bb preorder-call1:
pre: (tree^(x) & (sz i= size^(x)));
post: (tree^(xl) * true);
{
	assume (! (x l== nil));
	int x.key := n;
	int n1 := n + 1;
	loc xl := x.left;
}

bb preorder-call2:
pre: (tree^(x) & (sz i= size^(x)));
post: (tree^(xr) * true);
{
	assume (! (x l== nil));
	int x.key := n;
	int n1 := n + 1;
	loc xl := x.left;
	int n2 := preorder(xl; n1);
	loc xr := x.right;
}
